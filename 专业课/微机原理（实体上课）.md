---
tags: 大三上 专业课
---
# 前言

开课时间：2022.08.30-
关联笔记：[2020 西电计算机组成与体系结构 车向泉](../自学内容/计算机/计算机组成原理/2020%20西电计算机组成与体系结构%20车向泉.md) [微机原理（西电）](微机原理（西电）.md)

**作业：第一章 3,6  第二章 1,2,6,7,11,12,13,18**，第三章3,6,7,8,12,14
第四章：1，2，3，5，10，13；  
第五章：15；  
第六章：5，9，10，11，12；  
第七章：4，5




# 课程笔记

## 第一章. 微型计算机的基础与发展概论

### 1. 计算机中的数制和码值

1. 数制
- 十进制与二进制互化，二进制与十六进制互化

2. 码制
- 原码，反码，补码。
	- 原码：符号位+真值
		- 无右码(-127,+127)，且存在+0和-0
	- 反码
		- 与原码性质大体相同。
	- 补码
		- 解决0问题，（-128，+127），且无+0/-0之分。
	- **不涉及到浮点数内容**。

### 2. 计算机的基本结构

1. 冯诺依曼结构
- 取指---->译码->执行---->再取指
2. 指令系统与机器码
3. 硬件/软件/OS

### 3. 微型计算机的结构和系统

1. 结构框图
![|600](assets/Pasted%20image%2020220830093008.png)

### 4. 计算机的发展


## 第二章. 微处理器的结构和工作方式

### 2.1  8086CPU的内部结构和存储器组织

1. 8086CPU的内部结构与工作过程
![|700](../Excalidraw/Drawing%202022-09-01%2010.34.26.excalidraw)

- ALU：算术逻辑单元
- EU：执行单元
- 8086：数据总线16位，地址总线20位
- 物理地址：地址总线的实际地址（直接译码结果）。
- 指令队列：从串行执行->并行执行。
- 整体过程图（抽象）如下：
![|150](../Excalidraw/Drawing%202022-09-01%2010.46.38.excalidraw.md)
2. 8086CPU内部寄存器

1) 数据寄存器
- AX ——累加器（AH+AL）
	- 很多指令默认为AX
- BX——基址寄存器
- CX——计数寄存器（CH+CL）
	- 也可以做计数器
- DX——数据寄存器
	- 在乘除法时有默认应用
	- 对于I/O设备时，设备编号默认放入DX中

2) 指针寄存器
- SP——堆栈指针
- BP——基址指针

3) 变址寄存器
- SI——源变址寄存器
- DI——目的变址寄存器

4) 段寄存器（物理地址=段地址\*16H（左移四位）+偏移地址   如：CS\*16+IP）
- CS——代码段寄存器（Code）
- DS——数据段寄存器（Data）
- SS——堆栈段寄存器（Stack）
- ES——附加段寄存器（其与DI配对）

5) 指令指针
- IP——程序指针（CS\*16+IP）
	- 执行一次取址操作后，IP=IP+1

6) 标志寄存器（FLAG）
![|600](assets/Pasted%20image%2020220901112914.png)
- 状态标志（由ALU的运算结果确定，不受人为干预）
	- CF——进位标志
	- PF——**奇偶校验标志**（只看第八位）
	- AF——辅助进位标志（**只在BCD码运算时启用，且只在AL处（在三四位处）检验**）
	- ZF——零标志（最常用）
	- SF——符号标志（负标志）
	- OF——溢出标志（有符号数运算时考虑）
- 控制标志（不受ALU影响）
	- DF——方向标志（只跟SI，DI关联 递增/递减）
	- IF——中断标志（屏蔽中断）
	- TF——陷阱标志（设置断点，单步调试使用）

3. 8086CPU的存储器组织（对存储器的管理）

1) 分段结构
- 物理地址=段地址\*16H（左移四位）+偏移地址
- 采用其原因：1. 当时收到限制    2. 不同计算机保持内容一致（绝对地址无法保证兼容性）

### 2.2 8086CPU的引脚功能与8086的工作模式

- 地址总线为单方向，主要是CPU向外发送的。
- 引脚接地：电路的抗干扰性能提高。

- 计算机的最小组成
	- 存储器的分段与分体结构
	![|600](assets/Pasted%20image%2020220913080446.png)

- BHE非：高地址有效
- 74LS373->接过去，为两个512kb。
- 74LS245（数据总线缓冲器）->DIR（控制方向）（数据是双向的）
- 堆栈区以字为单位，取偶地址。

- CPU的时序
	- T1负责地址，T2-T4负责数据操作



## 第三章 8086的寻址方式与指令系统

### 1. 8086的寻址方式

- 立即数寻址
- 寄存器寻址
- 存储器寻址
	- 直接寻址
	- 间接寻址
	- 相对寻址
	- 基址变址寻址
	- 相对基址变址寻址
- 其他寻址


### 2. 指令机器码（略过）
- 机器码的编码规则


### 3. 指令系统

3.3.1  数据传送指令

1) 通用数据传送指令

- MOV 传送指令
	- 指令格式：MOV  目的，源
	- 指令功能：目的操作数←源操作数
	- CS、IP不参与传送类指令，其决定程序执行的下一条指令。（换句话说，**其不能作为目的操作数**）
	- 同样，**立即数也不能作为目的操作数**。
	- 寄存器之间也可以传送，类型需要一致。**单挑指令不允许存储器与存储器之间进行数据传送**。
	- 立即数作为源操作数传送给存储器时，**需要添加修饰符**说明数据类型。
	![|600](assets/Pasted%20image%2020220913082920.png)

- 堆栈操作
	- 所有指令都是字操作，执行对齐模式，保证均为偶地址。
	- 进栈指令 PUSH (Push  Word  onto  Stack)
		- 指令格式： PUSH   源
		- 指令功能： 将源操作数推入堆栈
		- 执行PUSH操作后，使SP←SP-2，再把源操作数压入SP指示的位置上。
		- 例：PUSH AX的操作过程： 
			- 1. SP ← SP - 2
			- 2. ( SP )← AX
	- 出栈指令 POP (Pop  Word  off  Stack)
		- 指令格式： POP    目的
		- 指令功能：把当前SP所指向的一个字送到目的操作数中            
		- 每执行一次出栈操作，SP←SP+2，SP向高地址方向移动，指向新的栈顶。
		- 例：POP CX的操作过程：
			- 1. CX← (SP)
			- 2. SP ← SP + 2

- 交换指令 XCHG  (Exchange)
	- 指令格式： XCHG	目的，源
	- 指令功能： 源操作数和目的操作数相交换
	- 交换可以在寄存器之间、寄存器与存储器之间进行，但**段寄存器不能作为操作数**，也不能直接交换两个存储单元中的内容。

- 表转换指令 XLAT (Table Lookup-Translation)
	- 指令格式： 
		- XLAT 	转换表     ；“转换表”为表格首地址
		- 或    XLAT	    	      ；“转换表”可省略不写
	- 指令功能： 将1个字节从一种代码转换成另一种代码
	- 使用XLAT指令前，应建立一个表格，最多256个字节，且置：BX←转换表始址，AL← 表头地址到要找的某项间的位移量。
	- 指令执行时，根据位移量从表中查到转换后的代码值，送入AL中。
	- 例：七段数码管
```asm
TABEL  DB	40H，79H，24H，30H，19H；七段码表格
		     DB	12H，02H，78H，00H，18H
		        …
MOV	  AL，5			；AL←数字5的位移量
MOV	  BX，OFFSET  TABLE	；BX←表格首地址
XLAT  TABLE			；查表得AL=12H
```

2) 输入输出指令

- IN 输入指令 
	- 指令格式：	
		- IN  AL，端口地址	；AL←从8位端口读入1字节。 或  IN  AX，端口地址	；AX←从16位端口读入1个字
		- IN  AL，DX		；端口地址存放在DX中。  或  IN  AX，DX
	- 超过8位的数据，不允许直接写入。需要先MOV去DX，再用IN读取。例子如下：
```Asm
MOV  DX，310H	   ；端口地址310H先送入DX
IN	   AL，DX	   ；AL←310H端口内容
```

- OUT 输出指令 (Output)
	- 指令格式：
		- OUT   端口地址，AL	；8位端口←AL内容    或    OUT   端口地址，AX	；16位端口←AX内容；
		- OUT   DX，AL		；DX=端口地址    或    OUT   DX，AX
	- 超过8位数据的处理与IN一致。
```Asm
MOV	  DX，300H	；DX指向16位端口
OUT	  DX，AX		；300H端口←AL内容
					；301H端口←AH内容
```

3) 地址目标传送指令 (Address Object Transfers)

- LEA 取有效地址指令 (Load Effective Address)
	- 指令格式： LEA	 目的（R/M，一般为R），源（M）
	- 指令功能： 取源操作数地址的偏移量，送到目的操作数（取的不是数值，而是偏移地址）
		- 例：设：SI=1000H，DS=5000H，(51000H)=1234H，指令执行结果如下：
			- LEA	BX，［SI］		      ；[SI]的偏移地址为1000H，BX←1000H
			- MOV	BX，［SI］	      ；偏移地址为1000 H单元的内容为1234H，指令执行后，BX←1234H 
		- 例：下面两条指令是等价的，它们都取TABLE的偏移地址，送到BX中。
			- LEA	BX，TABLE
			- MOV	BX，OFFSET  TABLE

- LDS 将双字指针送到寄存器和DS指令  (Load Pointer using DS)
	- 指令格式： LDS	目的，源（M）
	- 指令功能： 从源操作数指定的存储单元中，取出1个4字节地址指针，送进目的寄存器DS和指令中指定的目的寄存器中。
	- 例 设：DS=1200H，(12450H)=F346H，(12452H)=0A90H。执行指令：LDS    SI，［450H］		
		- 结果：存储单元前2字节内容为F346H ，SI←F346H
		- 后2字节内容为0A90H ，DS←0A90H

- LES 将双字指针送到寄存器和ES指令  (Load Pointer using ES)
	- 指令格式： LES	目的，源（M）
	- 指令功能：与LDS指令的操作基本相同，但段寄存器为 ES，目的操作数常用DI。
	- 例：设DS=0100H，BX=0020H，(01020H)=0300H，(01022H)=0500H
		- LES	 DI，［BX］		；存储单元前2字节内容为0300H ，SI←0300H，后2字节内容为0500H ，ES←0500H

4) 标志传送指令(Flag Transfers)

- LAHF 标志送到AH指令 （Load AH from Flags)
	- 指令格式： LAHF
	- 指令功能： 把标志寄存器的SF、ZF、AF、PF和CF传送到AH寄存器的相应位。


![|600](assets/Pasted%20image%2020220913093934.png)

- SAHF AH送标志寄存器 (Store AH into Flags)
	- 指令格式： SAHF
	- 指令功能： 把AH内容存入标志寄存器。指令功能与LAHF 的操作相反。

- PUSHF 标志入栈指令(Push Flags onto Stack)
	- 指令格式： PUSHF
	- 指令功能： 把整个标志寄存器的内容推入堆栈，并使SP←SP-2。

- POPF 标志出栈指令 (Pop Flags off Stack)
	- 指令格式： POPF
	- 指令功能： 把SP所指的一个字，传送给标志寄存器FLAGS，并使SP←SP+2。

5) 传送类指令的特点
- **除了SAHF，POPF之外**，原则上不影响FLAGS（未进行ALU运算）。



3.3.2  算术运算指令

1. 加法指令 (Addition)

- ADD  加法指令
	- 指令格式： ADD	目的，源
	- 指令功能：目的←源+目的

- ADC  带进位的加法指令 (Addition with Carry)
	- 指令格式： ADC	目的，源
	- 指令功能： 目的←源+目的+CF

- 它们的源操作数可以是寄存器、存储器或立即数。
- 目的操作数只能用寄存器和存储单元，存储单元可以有表3.2中所示的24种表示方法。   
- 源和目的操作数不能同时为存储器，而且它们的类型必须一致，即都是字节或字。

- INC  增量指令  (Increment)
	- 指令格式： INC	目的
	- 指令功能： 目的 ← 目的 + 1
	- 目的操作数可以是通用寄存器或内存。指令执行后影响AF、OF、PF、SF和ZF，但进位标志CF 不受影响。

- AAA   加法的ASCII调整指令 (ASCII Adjust for Addition)（非压缩=>一个字节中只有一个BCD码）
	- 指令格式： AAA
	- 指令功能：
		- 用ADD或ADC指令对两个非压缩BCD数数或以ASCII码表示的十进制做加法后，结果在AL中，用此指令将AL中的结果进行调整。
		- 另外，若AF=1，表示有进位，则进到AH中。


![|500](assets/Pasted%20image%2020220915103415.png)

![|500](assets/Pasted%20image%2020220915103437.png)

- DAA  加法的十进制调整指令   (Decimal Adjust for Addition)（压缩的BCD码)
	- 指令格式： DAA
	- 指令功能： 对两个压缩BCD数相加后的结果（已在AL中）进行调整。
	- 注意：要对AL中高半字节和低半字节分别进行调整

![|500](assets/Pasted%20image%2020220915103656.png)
2. 减法指令  (Subtraction)

- SUB  减法指令  (Subtraction)
	- 指令格式： SUB	目的， 源
	- 指令功能：目的 ← 目的 - 源

- SBB  带借位的减法指令 (Subtract with Borrow)
	- 指令格式： SBB	目的，源
	- 指令功能： 目的 ← 目的 - 源 - CF

- DEC  减量指令  (Decrement)
	- 指令格式： DEC	目的
	- 指令功能：目的 ← 目的 - 1

- NEG  取负指令  (Negate)
	- 指令格式： NEG   目的
	- 指令功能：目的 ← 0 - 目的

- CMP  比较指令   (Compare)
	- 指令格式： CMP	  目的，源
	- 指令功能：Flag   <= 目的 - 源  ，结果不回送到目的，仅反映在标志位上。

- AAS 减法的ASCII调整指令 (ASCII Adjust for Subtraction)
	- 指令格式： AAS
	- 指令功能：在用SUB或SBB指令，对两个非压缩BCD数，或以ASCII码表示的十进制数相减后，对AL中所得结果进行调整，如有借位，则CF置1。

- DAS  减法的十进制调整指令 (Decimal Adjust for Subtraction)
	- 指令格式： DAS
	- 指令功能： 在用SUB或SBB指令，对两个压缩BCD数相减（结果已存在AL中）后，进行调整。
	- 同样，它也要对AL中高半字节和低半字节分别进行调整。

3. 乘法指令 (Multiply)

- MUL  **无符号数**乘法指令   (Multiply)
	- 指令格式： MUL  源
	- 指令功能： 把源操作数和累加器中的数，都当成无符号数，然后将两数相乘。
		- 其中有一个操作数一定是累加器。
		- **如果源操作数是1个字节，则 AX ← AL * 源**
		- **若源操作数是1个字，  则 (DX，AX) ← AX * 源**
		- 源操作数可以是寄存器或存储单元，**不能是立即数**（不能确定其为字还是字节，无法确认是8位还是16位，无法确定选择AL/AX）
		- 当源操作数是存储单元时，应在操作数前加BYTE或WORD，说明是字节还是字。
		- MUL指令执行后影响CF和OF标志。
		- 如果结果的高半部分不为零，则CF、OF均置1。否则，CF、OF均清0。
		- 通过测试这两个标志，可检测并去除结果中的无效前导零。

- 例：设AL=55H，BL=14H，计算它们的积。
	- 只要执行下面这条指令：MUL	   BL
	- 结果：AX=06A4H
	- 由于AH=06H≠0，高位部分有效，所以置CF=1和OF=1。

例：
```asm
   MUL    DL			；AX←AL*DL
   MUL    CX			；(DX，AX)←AX*CX
   MUL    BYTE［SI］	；AX←AL*(内存中某字节)，BYTE说明字节乘法
   MUL    WORD［BX］	；(DX，AX)←AX*(内存中某字)，WORD说明字乘法
```

- IMUL  整数乘法指令   (Integer Multiply)（带符号数）
	- 指令格式： IMUL	 源
	- 指令功能：把源操作数和累加器中的数，都作为带符号数，进行相乘。(注意首位需要异或)
	- 存放结果的方式与MUL相同，最后给乘积赋予正确的符号。
	- 指令执行后，如果乘积的高半部分不是全0或全1，则置CF=1，OF=1。 若结果高半部分为全0或全1，则使CF=0，OF=0。这样来决定是否需要保存积的高半部分。

- 例：设AL=-28，BL=59，试计算它们的乘积。
```asm
 IMUL     BL	；AX=F98CH= - 1652，CF=1，OF=1
```

- AAM  乘法的ASCII调整指令 (ASCII Adjust for Multiply)
	- 指令格式： AAM
	- 指令功能：对存于AL的两个非压缩BCD数相乘的积进行调整，结果在AX中，高位放AH，低位在AL。
	- 两个ASCII码数相乘前，应先屏蔽掉每个数字的高半字节。
	- 调整过程： 把AL内容除以10，商放在AH中，余数在AL中。即
		- AH ← AL/10所得的商
		- AL ← AL/10所得的余数
		- 指令执行后，将影响ZF、SF和PF。


4. 除法指令   (Division)

- DIV  无符号数除法指令  (Division，unsigned)
	- 指令格式： DIV	源
	- 指令功能： 对两个无符号二进制数进行除法操作。
	- 如果源操作数为字节，被除数必须放在AX中，并且有：
		- AL ← AX/源(字节)的商
		- AH ← AX/源(字节)的余数
	- 要是被除数只有8位，必须把它放在AL中，并将AH清0，然后相除。
	- 若源操作数为字，被除数必须放在DX和AX中，并且有：
		- AX ← (DX，AX)/源(字)的商
		- DX ← (DX，AX)/源(字)的余数
	- 要是被除数只有16位，除数也是16位，则必须将16位被除数送入AX，再将DX清0，然后相除。
	- 与被除数和除数一样，商和余数都是无符号数。


- IDIV  整数除法指令  (Integer Division)
	- 指令格式： IDIV	 源
	- 指令功能：功能与DIV相同，但操作数都必须是带符号数，商和余数也都是带符号数，而且规定余数的符号和被除数的符号相同。
		- 进行除法操作时，如果商超过了目标寄存器AL或AX所能存放数的范围，计算机会自动产生除法错中断，相当于执行了除数为0的运算，所得的商和余数都不确定。
		- 对于带符号数除法指令，字节操作时要求被除数为16位，字操作时要求被除数为32位。
		- 如果被除数不满足这个条件，不能简单地将高位置0，而应该先用下面的符号扩展指令 (Sign Extension)将被除数转换成除法指令所要求的格式，再执行除法指令。


- AAD   除法的ASCII调整指令 (ASCII Adjust for Division)
	- 指令格式：AAD
	- 指令功能：在做除法前把BCD码转换成二进制数。
	- 前面介绍的调整指令，都是在用加法、减法和乘法指令后，紧跟着用一条AAA、AAS或AAM指令，对运算结果进行调整。
	- 而除法的ASCII调整指令不同，它是在除法之前进行的。
	- 在把AX中的两位非压缩BCD数除以一个非压缩BCD数之前，先用AAD指令，把AX中的被除数调整成二进制数，并存入AL，然后才能用DIV指令进行运算。调整的过程为：
		- AL←AH×10+AL
		- AH←00
	- 本指令根据AL寄存器的结果影响SF、ZF和PF


- CBW  把字节转换为字指令   (Convert Byte to Word) （不影响flag）
	- 指令格式： CBW
	- 指令功能： 把AL中字节的符号位扩充到AH的所有位，这时AH被称为是AL 的符号扩充。
	- 如果AL中的D7=0，就将这个0扩展到AH中去，使AH=00H，即
	- ![|500](assets/Pasted%20image%2020220915112152.png)
   - 若AL中的D7=1，则将这个1扩展到AH中去，使AH=FFH，即
   - ![|500](assets/Pasted%20image%2020220915112231.png)
   -  CBW指令执行后，不影响标志位。


- CWD   把字转换成双字指令  (Convert Word to Double Word)  （不影响flag）
	- 指令格式： CWD
	- 指令功能： 把AX中字的符号位扩充到DX寄存器的所有位中去。
	- 若AX中的D15=0，则DX←0000H，即
	- ![|500](assets/Pasted%20image%2020220915112400.png)
	- 若AX中的D15=1，则DX←FFFFH，即
	- ![|500](assets/Pasted%20image%2020220915112421.png)


3.3.3  逻辑运算和移位指令

1) 逻辑运算指令

- NOT   取反指令 (Logical Not)
	- 指令格式： NOT	  目的
	- 指令功能：目的←目的取反
	- 目的操作数可以是8位或16位寄存器或存储器，对存储器操作数要说明类型。

- 以下为双操作数指令。源操作数可以是8或16位立即数、寄存器、存储器，目的操作数只能是寄存器或存储器，两个操作数不能同时为存储器。
- 指令执行后，均将CF和OF清0，ZF、SF和PF反映操作结果，AF未定义，源操作数不变。

- AND 逻辑与指令 (Logical AND) 
	- 指令格式： AND	目的，源
	- 指令功能： 目的←目的∧源 
	- 主要用于使操作数的某些位保留(和“1”相与)，而使某些位清除(和“0”相与)。
	- 应用场合：部分位清零，其余位不变。

- OR 逻辑或指令 (Logical OR)
	- 指令格式： OR	目的，源
	- 指令功能： 目的←目的∨源 
	- 它主要用于使操作数的某些位保留(和“0”相或)，而使某些位置1(和“1”相或)。
	- 应用场合：部分位置1，其余位不变。

- XOR 异或操作指令 (Exclusive OR)
	- 指令格式： XOR	目的，源
	- 指令功能： 对两个操作数进行按位逻辑异或运算，结果送回目的操作数，即
	- 目的←目的 异或 源
	- 用于使操作数的某些位保留(和“0”相异或)，而使某些位取反(和“1”相异或)。
	- 应用场合：部分位取反，其余位不变。

- TEST 测试指令 (Test)
	- 指令格式： TEST    目的，源
	- 指令功能： 目的∧源，并修改标志位，但不回送结果
	- 它常用在要检测某些条件是否满足，但又不希望改变原有操作数的情况下。

2) 移位指令

![|600](assets/Pasted%20image%2020220915115527.png)

- SAL 算术左移指令 (Shift Arithmetic Left)
	- 指令格式：SAL 	 目的，计数值

- SHL 逻辑左移指令 (Shift Logic Left)
	- 指令格式：SHL 	 目的，计数值
	- 指令功能：以上两条指令的功能完全相同。

- 均将目的操作数的各位左移，每移一次，最低位LSB补0，最高位MSB进标志位CF。移动一次，相当于将目的操作数乘以2。
- 计数值表示移位次数，可以是1。若大于1，则用CL存放，并要事先将次数存入CL。
- 移位次数最多为31(即00011111B)。
- 例
```Asm
MOV	   AH，00000110B；AH=06H
SAL	   AH，1		 ；将AH内容左移一位后，
					 ；AH=0CH
MOV	   CL，03H		 ；CL←移位次数3
SHL	   DI，CL		 ；将DI内容左移3次
SAL	   BYTE  PTR［BX］，1	
					 ；将内存单元字节左移1位
```

- SHR 逻辑右移指令 (Shift Logic Right)
	- 指令格式：SHR   目的，计数值
	- 指令功能：使目的操作数各位右移，每移一次，最低位进入CF，最高位补0。
	- 右移次数由计数值决定，同SAL/SHL指令一样。
	- 若目的操作数为无符号数，每右移一次，使目的操作数除以2。

- 例3.68  用右移的方法做除法133/8=16…5，即：
```Asm
MOV	AL，	10000101B	；AL=133
MOV	CL，	03H		；CL=移位次数
SHR	AL，	CL		；右移3次，AL=10H，余数5丢失
```

- SAR 算术右移指令 (Shift Arithmetic Right)
	- 指令格式： SAR目的，计数值
	- 指令功能：每移位一次，最低位进入CF，但最高位(即符号位)保持不变，而不是补0。相当于对带符号数进行除2操作。

- 例：用SAR指令计算-128/8=-16的程序段如下：
```Asm
MOV	   AL，10000000B	；AL= 128
MOV	   CL，03H			；右移次数为3
SAR	   AL，CL			；算术右移3次后，
						；AL = 0F0H = -16
```

3)  循环移位指令 (Rotate)

- 算术逻辑移位指令，移出的操作数数位均丢失。循环移位指令则把数位从操作数的一端移到其另一端，从操作数中移走的位不会丢失。

- ROL 循环左移指令 (Rotate Left)
	- 指令格式： ROL  目的，计数值
	![|500](assets/Pasted%20image%2020220920081123.png)

- ROR 循环右移指令 (Rotate Right)
	- 指令格式： ROR  目的，计数值
	![500](assets/Pasted%20image%2020220920081131.png)

- RCL 通过进位位循环左移  (Rotate through Carry Left)
	- 指令格式： RCL  目的，计数值
	![|500](assets/Pasted%20image%2020220920081152.png)

- RCR 通过进位位循环右移 (Rotate through Carry Right)
	- 指令格式： RCR  目的，计数值
	![|500](assets/Pasted%20image%2020220920081158.png)

- 目的操作数可以是8/16位的寄存器操作数或内存操作数，计数值含义同上，即1或由CL指定。
- ROL和ROR为小循环移位指令，没有把CF包含在循环中；RCL和RCR为大循环指令，把 CF作为整个循环的一部分参加循环移位。
- CF的值由最后一次被移出的值决定。

3.3.4  字符串处理指令

- 字符串指令执行时，必须遵守以下的隐含约定：
	- 源串位于数据段中，源串字符的始址(或末址)为DS：SI。
	- 目的串位于附加段中，目的串字符的始址(或末址)为ES：DI。
	- 每执行一次字符串指令，指针SI和DI会自动修改，指向下一待操作单元。
	- DF标志控制字符串处理的方向：
		- DF＝0递增。执行一次字节串操作，SI、DI各+1；字串操作，SI和DI各+2；
		- DF=1递减。执行一次字节串操作，SI、DI各1；字串操作，SI和DI各2。
		- STD指令使DF=1，CLD指令使DF=0。
- CX=要处理的字符串长度(字节或字数)。
- 为加快串运算指令的执行速度，可在基本指令前加重复前缀，使数据串指令重复执行。每重复执行一次，SI和DI都根据方向标志自动修改，CX的值则自动减1。能与基本指令配合使用的重复前缀有：
	- REP			无条件重复			  (Repeat)
	- REPE/REPZ	 	相等/结果为零则重复	  (Repeat while Equal/Zero)
	- REPNE/REPNZ	不相等/结果非零则重复 (Repeat while Not Equal/Not Zero) 

- MOVS(B/W)字符串传送指令 (Move String)
	- 指令格式： MOVS    目的串， 源串
	- 指令功能：把源串中的一个字节或字，传送目的串中，且自动修改指针SI和DI。
	- 利用MOVS指令，能很方便地将数据从内存的某一地址(源地址)传送到另一个地址(目的地址)，还能自动修改源和目的地址。若使用重复前缀，可用一条指令传送一批数据。

- CMPS（B/W） 字符串比较指令 (Compare String)
	- 指令格式： CMPS	  目的串， 源串
	- 指令功能：将**源串**中数据减去**目的串**数据，但不改变两数据串的原始值，结果反映在标志位上。操作后源串和目的串指针会自动修改。
	- 常用此指令来比较两个串是否相同，并由其后的条件转移指令，根据CMPS执行后的标志位值，决定程序的转向。
- CMPS指令前可加重复前缀,  下面每两条指令功能相同:
```Asm
REPE  CMPS	；若CX≠0(未比完)和
REPZ    CMPS	；ZF＝1(两串相等)，则重复
REPNE  CMPS	；若CX≠0(串没有结束)和串不相等
REPNZ    CMPS       ；(ZF=0)，则重复比较。
```

- SCAS 字符串扫描指令 (Scan String)
	- 指令格式： SCAS   目的串
	- 指令功能：从AL(字节操作)或AX(字操作)寄存器的内容，减去ES:DI为指针的目的串元素，结果反映在标志位上，但不改变源操作数。串操作后目的串指针DI会自动修改。
	- 利用SCAS指令，可在内存中搜索所需要的数据（关键字）。指令执行前，必须事先将它存在AL(字节)或AX(字)中。
	- SCAS指令前也可加重复前缀。

- LODS 数据串装入指令(Load String)
	- 指令格式： LODS   源串
	- 指令功能：把数据段中以SI作为指针的串元素，传送到AL(字节操作)或AX(字操作)中，同时修改SI。
	- 为该指令加重复前缀没有意义。因为每重复传送一次数据，累加器中的内容就被改写，执行重复传送操作后，只能保留最后写入的那个数据。

- STOS 数据串存储指令 (Store String)
	- 指令格式： STOS  目的串
	- 指令功能：将累加器AL或AX中的一个字节或字，传送到以ES:DI为目标指针的目的串中，同时修改DI，以指向串中的下一个单元。
	- STOS指令与REP重复前缀连用，即执行指令REP STOS，能方便地用累加器中的一个常数，对一个数据串进行初始化。例如，初始化为全0的串。


3.3.5  控制转移指令

![|500](assets/Pasted%20image%2020220922101816.png)

1. 无条件转移和过程调用指令  (Unconditional Transfer and Call)

- JMP 无条件转移指令 (Jump)
	- 指令格式： JMP	目的
	- 指令功能： 无条件地转移到目的地址去执行。
- 这类指令又分成两种类型：
	- **段内转移**或近(NEAR)转移。转移指令的目的地址和JMP指令在同一代码段中，转移时仅改变IP的内容，**段地址CS的值不变**。
	- **段间转移**，又称远(FAR)转移。转移指令的目的地址和JMP指令不在同一段中，**转移时，CS和IP的值都要改变**，程序要转移到另一个代码段去执行。
- 无条件转移指令
	- 就转移地址提供的方式而言，又可分为两种方式：
		- **直接转移**。在指令码中直接给出转移的目的地址，目的操作数用**一个标号**来表示。它又可分为段内直接转移和段间直接转移。
		- **间接转移**。目的地址包含在某个16位寄存器或存储单元中，CPU必须根据寄存器或**存储器**寻址方式，间接地求出转移地址。同样，这种转移类型又可分为段内间接转移和段间间接转移。
	- 所以无条件转移指令可分成段内直接转移、段内间接转移、段间直接转移和段间间接转移四种不同类型和方式，如表3.10所示。
	- 若转移范围在-128~+127字节内，称为**短转移**，指令中只需要用8位位移量，在标号前加说明符SHORT。
	- 若位移量是16位，称为**近转移**，目的地址与当前IP的距离在-32768~+32767字节之间。可加说明符NEAR  PTR，也可省略。这类指令用得最多。

- 段内直接转移指令
	- 指令格式：
	    - JMP   SHORT   标号
	    - JMP   NEAR  PTR  标号  (或JMP   标号)
		- 段内相对转移指令，目的操作数均用标号表示。
		- 转向的有效地址=IP+8位/16位位移量(DISP)。
- 段内间接转移指令
	- 转向的16位地址存放在一个16位寄存器或字存储器单元中。
	- 用寄存器间接寻址的段内转移指令，转向的地址存放在寄存器中，执行操作：IP←寄存器内容。
	- 用存储器间接寻址的段内转移指令，先计算出存储单元的物理地址，再从中取一个字送到IP。即IP←字存储单元内容。
- 段间直接(远)转移指令
	- 指令中用远标号直接给出转向的CS:IP，程序从一个代码段转到另一个代码段。
- 段间间接转移指令
	- 操作数为存储器，要转移的目的地址CS:IP存放在存储器中。需加说明符DWORD PTR，表示转向地址需取双字。

- 过程调用指令
	- 过程调用和返回指令 (Call and Return)
		- 把某些能完成特定功能又常用的程序段，编写成独立模块，称为过程(Procedure)或子程序(Subroutine)。
		- 在主程序中用CALL语句调用这些过程，格式为：
			- CALL  过程名
		- 过程以PROC开头，ENDP结束。过程中要安排一条返回指令RET，过程执行完后能正确返回主程序。
		- 若在过程运行中又调用另一过程，称为过程嵌套。
		- 主程序和过程在同一代码段，称为近调用，不在同一段则称为远调用。
		- 过程调用的寻址方式与转移指令类似，但没有段内短调用。由于调用结束后需返回原程序继续运行，要执行保护和恢复返址操作，比转移复杂。
- CALL指令分两步执行：
	- 第一步：返址入栈，将CALL下面指令的地址推入堆栈
	- 近调用执行的操作：
		- SP←SP-2，IP入栈
	- 远调用执行的操作：
		- SP←SP-2，CS入栈
	   - SP←SP-2，IP入栈
	- 第二步：转到子程序入口执行相应的子程序。入口地址由CALL指令的目的操作数提供，寻址方法与JMP指令类似。
		- 执行过程中的RET指令时，从栈中弹出返址，使程序返回主程序继续执行。也有两种情况：
		- 从近过程返回，从栈中弹出1个字→IP，并且使SP←SP+2。
		- 从远过程返回，先从栈中弹出1个字→IP，并且使SP←SP+2；再弹出1个字→CS，并使SP←SP+2。
- CALL和RET的4种寻址方式
	- 段内直接调用和返回
	- 段内间接调用和返回
	- 段间直接调用
	- 段间间接调用

2. 条件转移指令 (Conditional Transfer)
- 将上条指令执行后的状态标志，作为测试条件，来决定是否转移。当条件成立，程序转向指令中给出的目的地址去执行；否则，仍顺序执行。
- 条件转移均为段内短转移，转移指令与目的地址必须在同一代码段中。转移距离范围为-128～+127字节。8位偏移量需用符号扩展法扩展到16位后才能与IP相加。
- 在指令中，目的地址均用标号表示，指令格式：
	- 条件操作符   标号
- 条件转移指令共18条，归类成直接标志转移和间接标志转移两大类。

- 直接标志转移指令
![|600](assets/Pasted%20image%2020220920094108.png)

- 间接标志转移
![|600](assets/Pasted%20image%2020220920094637.png)

3. 循环控制指令  
4. 中断指令

- 断点保护
	- FLAG,CS,IP入栈，IF，TF清零
	- 中断服务子程序
	- 通过中断向量表获取中断服务子程序入口地址
- INT n 软件中断指令  (Interrupt)
	- 软件中断指令，n为中断类型号，范围0~255。可安排在程序的任何位置上。
- INTO 溢出中断指令 (Interrupt on Overflow)
	- 当带符号数进行算术运算后，若OF=1，则可由INTO指令产生类型为4的中断; 若OF=0，则INTO指令不产生中断。
	- 为此，在带符号数进行加减法运算之后，必须安排一条INTO指令，一旦溢出就能及时向CPU提出中断请求，CPU可做出相应的处理。
- IRET  (Interrupt Return)
	- 中断返回指令IRET。被安排在中断服务程序的出口处，指令执行后，从堆栈中依次弹出程序断点和FLAGS的内容，使CPU继续执行原来被打断的程序。


3.3.6  处理器控制指令

1. 标志操作指令
- CLC，CMC和STC
	- 利用CLC指令，使进位标志CF清0，CMC指令使CF取反，STC指令则使CF置1。
- CLD和STD
	- 方向标志DF在执行字符串操作指令时用来决定地址的修改方向，CLD指令使DF清0，而STD指令则使DF置1。
- CLI和STI
	- 中断允许标志IF决定CPU能否响应可屏蔽中断请求，指令CLI使IF清0，禁止CPU响应这类中断。STI使IF置1，允许CPU响应。

2. 外部同步指令
- ESC  换码指令  (Escape)
	- 指令格式：ESC  外部操作码，源操作数
	- 指令功能：换码指令实现8086对8087协处理器的控制。
 - WAIT  等待指令  (Wait)
	- 通常跟在ESC指令之后。ESC指令执行后，8086 CPU处于等待状态，不断检测TEST引脚，若为高电平，则重复执行WAIT指令，处理器处于等待状态；如变为低电平，便退出等待状态，执行下条指令。
 - LOCK  封锁总线指令 (Lock Bus)
	- 可加在任何指令的前面。凡带有LOCK前缀的指令在执行过程中，将禁止其它处理器使用总线。

3. 停机指令和空操作指令
- HLT  停机指令  (Halt)
	- 使CPU进入暂停状态，当下列情况之一发生时，则脱离暂停状态：
	- 在RESET线上加复位信号；
	- 在NMI引脚上出现中断请求信号；
	- 在允许中断的情况下，在INTR引脚上出现中断请求信号。
	- 程序中常用HLT指令来等待中断的出现。
 - NOP  空操作或无操作指令  (No Operation)
	- 单字节指令，执行时耗费3个时钟周期的时间，但不完成任何操作。


## 第四章 汇编语言程序设计

### 4.1 汇编语言程序格式

1. 指令语句
- 完整的指令语句由4部分组成，格式：标号：指令助记符   操作数   ；注释
2. 伪指令语句
3. 表达式与运算符

- 完整的汇编语言框架

### 4.2 DOS功能调用
### 4.3 汇编语言程序设计


## 第五章 存储器
### 5.1 存储器分类
- RAM和ROM的判断标准

### 5.2 随机存储器RAM

### 5.3 ROM存储器

### 5.4 存储器的连接




# 课程评价
