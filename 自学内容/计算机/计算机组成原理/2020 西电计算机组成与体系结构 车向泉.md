---
tags: 自学 计算机 计算机组成原理
---

# 前言
 
课程链接：[计算机组织与体系结构 (chaoxing.com)](http://mooc1.chaoxing.com/course/205810329.html)
或者查看b站链接：[西电计算机组成原理_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1XF41137NW?spm_id_from=333.999.0.0)（缺少第一章，内容与上述一致）

课程PPT：见资源链。
教材：《计算机组成与系统结构》 裘雪红，西安电子科技大学出版社，2012.3

# 课程笔记

## 第一章  绪论

本章主要只涉及一些基础概念，只有最后部分涉及到公式计算。

### 1.1 计算机的发展史

机械计算器->电子管计算机->晶体管计算机->中小规模集成电路计算机->超大规模集成电路计算机->高性能智能计算机
摩尔定律及当前情况

### 1.2 计算机的基本组成

主要分为**硬件系统**与**软件系统**。
1. 早期冯诺依曼计算机组成
![|600](https://i.imgur.com/nZEfk1u.png)

其特点：指令和数据放在存储器中，并可按地址访问。在控制器的控制下，指令被逐条从存储器中取出来执行，产生控制流，在控制流的驱动下完成指令的功能。以运算器为中心，输入/输出设备通过运算器与存储器传送数据。

2. 早期PC机与当前PC机
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/Uqhrzag.png" width="60%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/nicvuTU.png" width="60%" />
			</center>
		</td>
	</tr>
</table>

### 1.3 计算机的分层结构

根据不同的机构，对应的工程师也不同。此处需注意计算机组成原理和计算机系统结构的区别：
- 计算机系统结构：从外部研究计算机系统。它是使用者（机器语言、汇编语言、系统程序员）所看到的物理计算机的抽象，是编写出能够在机器上正确运行的程序所必须了解到的计算机的属性。主要为由程序员所看到的计算机系统的属性，即概念性结构及功能特性。
- 计算机组成：从计算机系统的内部来研究计算机的构成，主要内容包括：运算方法、CPU 组成、主存储器和输入输出设备、输入输出接口等。主要为计算机系统的**逻辑实现**，包括最低层内部算法、数据流、控制流的逻辑实现。
- 计算机实现：计算机组成的物理实现。如集成电路芯片、电子元器件、部件、插头、插座
- 三者之间的联系：系统结构决定了计算机的总体属性，组成是体现这些属性的逻辑设计，而实现则是用具体的器件来实现逻辑功能。

### 1.4 计算机的分类及性能描述

重点侧重于计算机的**性能指标**。还涉及基准测试程序，性能测试方法等。
- 每秒钟执行指令的百万条数MIPS
- 每秒钟执行浮点数的百万次操作的数量MFLOPS
- 吞吐量
- 响应时间（执行时间）
- CPU时间
- 处理器数量

**Amdahl定律**：计算机系统中某一部件由于采用某种更快的执行方式后，整个系统性能的提高与这种执行方式的使用频率或占总执行时间的比例有关。
![|500](https://i.imgur.com/EOK2jYU.png)
影响因素及具体的计算方法如下：
1. 可改进部分在原系统总执行时间中所占的比，称为可改进比例，用$f_e$表示。例如，程序的总执行时间为100s，可改进的部分是其中的20s，则$f_e$＝0.2。可见，$f_e$总是小于或等1的。
2. 可改进部分改进后性能提高的程度，通常用部件加速比re来表示某部件改进后性能提高的比例。例如，某部件改进后，执行时间由原来的20s减少到5s，则部件加速比$r_e$＝20/5＝4。可见，$r_e$一般是大于1的。
![|350](https://i.imgur.com/7LXhgVX.png)

【例1.1】某Web服务器系统，采用新的CPU以提高其性能，新的CPU处理Web服务器应用程序的运行速度是原来处理器的10倍，同时假定此CPU有40%的时间用于计算，另外60%的时间用于等待I/O，则进行这一升级后，所得到的总的加速比是多少？
解：由上述题意可知，$f_e$＝0.4，$f_e$＝10，则
	Sp＝1/[(1－0.4)＋0.4/10]≈1.56
由计算可见，既使某一部件的部件加速比已达10倍，但该部件仅影响到总执行时间的小部分，对整个计算机系统的贡献是有限的。所以，改进后系统的加速比只有1.5倍左右。

【例1.2】若计算机系统有三个部件a、b、c是可改进的，它们的部件加速比分别为30、30、20。它们在总执行时间中所占的比例分别是30％、30％、20％。试计算这三部件同时改进后系统的加速比。
解：多个部件可同时改进的情况下，Amdahl定律可表示为：
![|350](https://i.imgur.com/uom9sxi.png)


## 第二章  计算机系统中的数据表示

本章主要涉及计算机内部的原码/反码/补码/移码的数据表示，以用二进制表示整数及小数。最后提到几种常见校验码，并说明校验码的校验原理及更优改进方法。

### 2.0 数据表示与数据结构

-  数据表示：指能由机器硬件直接识别和引用的数据类型。由**硬件**实现的数据类型。
-  数据结构：面向计算机系统软件、面向应用领域所需处理的数据类型。由**软件**实现的数据类型。
- 两者关系：数据表示是数据类型的子集。数据表示的确定实质上是软、硬件的取舍问题。数据结构和数据表示是软、硬件的界面。

### 2.1 数据编码

1. 整数部分，小数部分的进制转换

【例】将十进制数730.8125转换成二进制数、八进制数。
【解】 ① 整数部分的转换：“除基取余，先低后高”
![|350](https://i.imgur.com/odb6sRU.png)
因此，(730)10＝(1332)8
![|350](https://i.imgur.com/xmr3YPC.png)
故：(730)10＝ (1011011010)2

 ② 小数部分的转换：“乘基取整，先高后低”
将十进制数(0.8125)10转换为八进制数：
0.8125×8＝6.5	整数部分＝6	（高位）
0.5×8＝4.0		整数部分＝4	（低位）
因此，(0.8125)10＝(0.64)8 

将十进制数(0.8125)10转换为二进制数：
0.8125×2＝1.625		整数部分＝1	（高位）
0.625×2＝1.25		整数部分＝1
0.25×2＝0.5		整数部分＝0
0.5×2＝1.0			整数部分＝1	（低位）
因此，(0.8125)10＝(0.1101)2

2. 原码：“符号－数值”表示法，符号位＋绝对值的真值

定点小数的**原码定义**：
![|350](https://i.imgur.com/k9GpdFv.png)
定点整数的**原码定义**：
![|350](https://i.imgur.com/VNEeFN7.png)

【例】若机器字长n＝8，则
[＋35]原 ＝(00100011)2
[－35]原 ＝27－(－35)＝(10000000)2＋(00100011)2＝(10100011)2
[＋0.8125]原＝(0.1101000)2
[－0.8125]原＝1－(－0.8125)＝(1.0000000)2＋(0.1101000)2＝(1.1101000)2

**原码的性质：**
- 带符号的绝对值表示，符号位为“0”表示该数为正，符号位为“1”表示该数为负。且“0”不惟一，存在+0和-0。
- 表示范围（机器字长为n）：
定点小数：－(1－$2^{-(n-1)}$ )～＋(1－$2^{-(n-1)}$)
定点整数：－($2^{(n-1)}$－1)～＋($2^{(n-1)}$－1) 
- 若字长为n，总共有2n个码点，但对应的真值只有2n－1个。
- 负数的原码大于正数的原码。

3. 补码：设模为M，一个数 X 补码的一般定义为：[ X ]补＝M＋X。
若X＞0，则模M作为超出部分被舍去，[ X ]补＝X，因而正数的补码就是其本身；
若X＜0，则 [ X ]补就是以 M 为模的补数。

无模运算与有模运算：对于某一确定的模，某数减去小于模的另一数，总可以用该数加上模与另一数绝对值之差来代替。→ 补码可以用加法实现减法运算。
假定M为模，若数a、b满足a＋b＝M，则称a、b互为补数。在有模运算中，减去一个数等于加上这个数对模的补数。

定点小数的**补码**定义：
![|350](https://i.imgur.com/j02MEyW.png)
定点整数的**补码**定义：
![|350](https://i.imgur.com/CVxvNQz.png)

**补码的性质：**
1. 符号位：用补码表示的数，若其最高位为“0”，则此数为正；若其最高位为“1”，则此数为负。
2. 补码中，0的表示唯一（与原码不同，无+0和-0之分）
3. 补码的表示范围：假设机器字长为n，则比原码多表示一个数。
- 用补码表示的定点小数，其表示范围为：－1≤X≤＋(1－$2^{-(n-1)}$ )；
- 用补码表示的定点整数，其表示范围为：－$2^{(n-1)}$≤X≤＋($2^{(n-1)}$－1)。 
4. 负数的补码值大于正数的补码值
5. 补码与真值、原码之间的相互转换：**“按位取反，末位加一”**：（换句话说，从右往左找第一个1，第一个1以后值不变，第一个1以前所有按位取反）
**数值部分自低位向高位搜索，第一个1及其以右的各位0保持不变，以左的各高位按位取反。**
![|450](https://i.imgur.com/814jlxw.png)
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/zj5Qmvv.png" width="80%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/4agLfKl.png" width="80%" />
			</center>
		</td>
	</tr>
</table>

例题：
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/JyytJ3w.png" width="70%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/xqu2hc9.png" width="90%" />
			</center>
		</td>
	</tr>
</table>

6. 补码的符号位扩展
定点小数：在其低位填充适当位数的“0”
定点整数：符号位扩展

【例】已知定点小数X1、X2用8位表示的补码如下：[X1]补＝0.1010110，[X2]补＝1.1100101。
现要将[X1]补、[X2]补扩展为16位表示，求16位表示的[X1]补、[X2]补。
【解】16位表示的[X1]补、[X2]补如下：
	[X1]补＝0.1010110 00000000
	[X2]补＝1.1100101 00000000

7. 补码的补位 从n位补成2n位
- 要将n位纯小数补码变为2n位，只需在末尾添加n个“0”即可。
- 将整数补码的模扩大2n倍，只需将[X]补的符号位向左复制n位即可。

【例】已知定点整数X1、X2用8位表示的补码如下：
	[X1]补＝01010110，[X2]补＝11100101。
	将[X1]补、[X2]补扩展为16位表示。
【解】16位表示的[X1]补、[X2]补如下：
	[X1]补＝00000000 01010110
	[X2]补＝11111111 11100101

8. 补码的算数右移（除2运算）
![|350](https://i.imgur.com/Zwg2rZG.png)
![|400](https://i.imgur.com/SV9HtR0.png)
9. 补码的算数左移（乘2运算）：已知[X ]补求[2X ]补只需将[X ]补的各位左移一位，末位补0。

【例】假设机器字长n＝8，已知[X1]补＝0.0110100，[X2]补＝1.0010110，求[2X1]补、[2X2]补。
【解】
	[2X1]补＝00.1101000＝0.1101000	未溢出
	[2X2]补＝10.0101100＝0.0101100	溢出 

10.**双符号位**（判断是否溢出）
变形补码：采用双符号位。左符是真正的符号位，右符用来判别“溢出”。当使用变形补码（双符号位）进行运算时，
- 若运算结果的两个符号位相同，则不发生溢出；
- 若运算结果的两个符号位相异，则结果溢出。此时，最高位为符号；次高位为溢出的数值而非符号。

4. 反码 

- 设机器字长为n位，定点小数的反码定义：
![|400](https://i.imgur.com/b9CMu7U.png)
- 设机器字长为n位，定点整数的反码定义：
![|400](https://i.imgur.com/VUzXVAw.png)

<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/l6hwKO7.png" width="50%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/6vTy6Ny.png" width="50%" />
			</center>
		</td>
	</tr>
</table>

【例】若机器字长n＝8，则
[＋35]反＝(00100011)2
[－35]反＝(28－1)＋(－35)＝(11111111)2－(00100011)2＝(11011100)2
[＋0.8125]反＝(0.1101000)2
[－0.8125]反＝(2－2-7)＋(－0.8125)＝(1.1111111)2－(0.1101000)2＝(1.0010111)2

反码与原码及真值之间的转换：
当X≥0时，由定义：[X]反＝[X]原＝X
当X＜0时，![|400](https://i.imgur.com/3AfWp7L.png)

5. 移码及其性质
- 符号位：“0”表示负，“1”表示正。当－$2^{(n-1)}$≤X＜0时，0≤[X]移＜$2^{(n-1)}$，即符号位为0;当0≤X＜$2^{(n-1)}$时，$2^{(n-1)}$≤[X]移＜$2^{n}$，即符号位为1
- “0”的移码表示是惟一的。
- 表示范围： n位机器字长，－$2^{(n-1)}$≤X＜$2^{(n-1)}$
- [X]移与X呈线性正比关系。当且仅当X＞Y，[X]移＞[Y]移。移码被广泛用来表示浮点数的阶。
- 移码与补码的关系（假设机器字长为n位）：移码和补码关系为**符号位取反**。

【例】假设机器字长n＝8，已知
X1＝＋101011，X2＝－110010，
求其原码、补码和移码。
【解】
[X1]原＝00101011 [X1]补＝00101011 [X1]移＝10101011 
[X2]原＝10110010 [X2]补＝11001110 [X2]移＝01001110

6. 数据的定点与浮点表示
定点数：小数点位置固定不变的数。
对于有符号定点整数：原码表示范围：－($2^{n-1}$－1) ～ ＋($2^{n-1}$－1)；补码表示范围：－$2^{n-1}$ ～ ＋$2^{n-1}$-1。
对于无符号定点整数：表示范围：0 ～ $2^{n}$－1
对于定点小数：原码表示范围：－(1-$2^{-(n-1)}$) ～ ＋(1-$2^{-(n-1)}$)；补码表示范围：－1 ～ ＋(1-$2^{-(n-1)}$)；
分辨率(最小变化单位)：$2^{-(n-1)}$。

溢出处理的方法：将CPU中状态寄存器的溢出标志位置位，转入溢出处理程序进行相应的处理。

7. 浮点数
（1）表示方法
![|500](https://i.imgur.com/sLVVpvf.png)
- 浮点数表示的数值为：(－1)Ms×M×BE 
- B：阶码的底(Base)，一般为2、4、8 或 16。

（2）**浮点数的规格化**
- 如果阶码的底为2，则规格化浮点数的尾数应满足条件：1/2≤|M|＜1
- 当尾数用补码表示时
1. 若尾数M≥0，由于[1/2]补＝0.1000…0，∴尾数应具有格式：M＝**0.1**xxx…x∴当M≥0时，[1/2]补≤[M]补＜[1]补
2. 若尾数M＜0，由于[-1/2]补＝1.1000…0，[-1]补＝1.000…0，为了使计算机判断方便，一般不把[-1/2]补列为规格化的数，而把[-1]补列为规格化的数，∴尾数应具有格式：M＝**1.0**xxx…x∴当M＜0时，[-1]补≤[M]补＜[-1/2]补
可以看出，数的前两位呈现**异或逻辑**。
3. 左规：若采用变形补码表示尾数，则当结果的尾数出现11.1xxx…x或00.0xxx…x的形式时，需将尾数左移1位，阶码减1，直到尾数为规格化形式为止。
4. 右规：当浮点运算结果的尾数出现01.xxx…x或10.xxx…x的形式时，并不一定溢出，应先将尾数右移1位，阶码加1，然后判断阶码是否溢出。

【例1】将十进制数173507转换为下述IBM370的短浮点数格式（32位）。
![|500](https://i.imgur.com/e2O82gd.png)
【解1】(173507)10＝(2A5C3)16＝(0.2A5C30)16×165＝ (0.2A5C30)16×220
所以数符S＝0，阶码E＝(64＋20)10＝(1010100)2；因此(173507)2的IBM370的短浮点数格式为：
![|500](https://i.imgur.com/gfxe52f.png)
可用十六进制书写为如下简单形式：542A5C30H。
【解2】(173507)10＝(2A5C3)16
	＝(0010 1010 0101 1100 0011)2
	＝(0.1010 1001 0111 0000 1100 0000)2×218
∴数符S＝0，阶码E＝(64＋18)10＝(1010010)2  其余解法同上


【例2】将十进制数173507转换为下述典型的32位浮点数格式。
![|500](https://i.imgur.com/Trdvp1J.png)
【解】(173507)10＝(2A5C3)16
	＝(0010 1010 0101 1100 0011)2
	＝(0.1010 1001 0111 0000 1100 0000)2×218
∴数符S＝0，阶码E＝(128＋18)10＝(10010010)2
因此(173507)2的该32位浮点数格式为：
![|500](https://i.imgur.com/zxTUXwS.png)
可用十六进制书写为如下简单形式：4952E180H。

注意：尾数M：23位二进制原码表示
阶码E：8位移码表示，偏置常数为(10000000)2
数符S：正数为0，负数为1
此格式规格化浮点数可表示的正数范围：
最大值：0.11…1（23个1）×211...1＝(1－2-23)×2127
最小值：0.10…0×200...0＝(1/2)×2-128＝2-129

5. 规格化浮点数的特点
- 机器零：当浮点数的尾数为0，阶码为最小值$-2^{l-1}$(移码表示)时，浮点数代码为00…0(全零)。有利于保证浮点零表示形式的惟一性，且当浮点数的尾数用原码表示时，机器零有“＋0” 和“－0”之分。
- 浮点数在数轴上的分布：前密后疏
- 表示格式：
1. 单精度（32位）：(－1)S×M×2E。正实数范围：1.47×10-39～1.70×10+38
2. 双精度（64位）正数范围：2. 78×10-309～9.00×10+307
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/tmZGZbQ.png" width="80%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/oLoOnVL.png" width="80%" />
			</center>
		</td>
	</tr>
</table>
- 浮点数的溢出：数的大小超出了浮点数表示范围。原因：指数部分太大，以至于无法用有限的指数字段表示出来。
1. 上溢：阶码大于机器能表示的最大阶码。机器必须转入溢出故障的中断处理程序进行相应的处理。
2. 下溢：阶码小于机器能表示的最小阶码。一般当作机器零处理，机器继续运行。
3. 如何降低上溢或下溢发生的可能性？采用双精度格式。
4. 表示范围：
![|700](https://i.imgur.com/kDLdxpI.png)
例题：
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/YhnYY8Y.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/2kPtX5j.png" width="90%" />
			</center>
		</td>
	</tr>
</table>

8. IEEE 754标准
1. 具体规定：
- 尾数用原码表示，小数点前隐含一个“1”。
- 基值隐含为2。
- 阶码用移码表示，移码的偏移值有专门约定：n位移码的偏移值为 2n-1－1。 
- 指数(阶码)的最大值、最小值作为特殊标记预留，用来标记某些异常事件或机器零。
- 单精度、双精度；单精度扩展、双精度扩展。

2. 表示方法
- 000…00 代表 “＋0”，100…00 代表 “－0”
- 其它实数：(－1)S×( 1＋0.M )×2E-偏移值
- 如果小数部分的尾数各位从左到右依次用m1、m2、m3、… 来表示，则整个浮点数的值为：(－1)S×( 1＋(m1×2-1)＋(m2×2-2)＋(m3×2-3)＋(m4×2-4)＋… )×2E-偏移值    注意：**以01111111为基准，非之前的10000000**

3. 单精度格式
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/5cbJdgT.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/ZiFaI9s.png" width="90%" />
			</center>
		</td>
	</tr>
</table>

4. 双精度格式
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/LSw1beE.png " width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/8lfCXlF.png" width="90%" />
			</center>
		</td>
	</tr>
</table>

5. 拓展格式：没有对扩展格式的细节做明确的规定。
**强烈建议**在实现基本格式操作数的运算时，采用与该基本格式对应的扩展格式进行运算，再将运算结果舍入为相应的基本格式，以保证运算精度。

6. 下溢的处理：渐进下溢（使用非规格化数，当指数是emin时，尾数不必进行规格化。）
- 使用渐进下溢时，x＝y 等价于x－y＝0 始终成立。
- 非规格化数无需加前导1，为了区别于规格化数，IEEE 754 标准规定：当阶码 e＝emin－1、尾数f≠0( f 中至少有一位不为零)时，浮点数为非规格化数，真值为 (－1)s×2emin×0. f 。
![|500](https://i.imgur.com/sZZEC91.png)

7. 舍入模式（就近舍入/朝0舍入/朝＋∞舍入/朝－∞舍入）
- 就近舍入：舍入到最接近的可表示值；当有两个最接近的可表示值时，首选“偶数”值。
- 朝0舍入：截尾且使取值的绝对值比原值的绝对值小，容易导致误差积累。
- 朝＋∞舍入：正数：只要多余位不全为0，则向最低有效位进1/负数：截尾
- 朝－∞舍入：正数：截尾/负数：只要多余位不全为0，则向最低有效位进1

8. 指数移码的偏移值
一般情况：8位移码，偏移值为128。11位移码，偏移值为1024。
IEEE 754标准：
- 单精度格式，8位移码的偏移值取127，因此有emax＝127，emin＝－126。
- 双精度格式，11位移码的偏移值取1023，因此有emax＝1023，emin＝－1022。
- 指数 emin－1 与 emax＋1 保留，用来表示零、非规格化数以及＋∞、－∞、NaN 等特殊记号。
- 原因：
	- 为了使 |emin|＜emax 条件成立，从而保证绝对值最小的浮点数的倒数（1/2emin）不上溢。
	- 虽然偏移值如此取值后，绝对值最大的浮点数的倒数（ 1/2emax）会发生下溢，但是下溢通常比上溢更容易处理，比如运算结果仍可以用 IEEE 754 规定的非规格化数来表示。

9. NaN与无穷：主要避免运算中出现异常情况，出现后也可正常继续求解。
10. 有符号0：当浮点数的指数为emin－1、尾数为全零时，表示此浮点数为零。由于符号位可以为0或者1，所以有两个零：＋0和－0。会影响诸如 if(x＝0)之类比较指令的判断结果，因此IEEE754 标准规定在比较时－0＝＋0。

【例2.16】若浮点数 x 的 IEEE 754 单精度存储格式为(42150000)16，求浮点数 x 的十进制真值。
【解】将16进制数展开后，可得二进制数格式如下：
![|500](https://i.imgur.com/3919f7J.png)
指数＝阶码e －(127)10
       ＝(10000100)2－(01111111)2＝(00000101)2＝(5)10
包括隐含位1的尾数＝1. f 
     ＝(1.001 0101 0000 0000 0000 0000)2＝(1.001 0101)2
因此 x ＝ (－1)s×2e-127×1. f
     ＝＋25×(1.0010101)2＝(100101.01)2＝(37.25)10

【例2.17】将数(22.78125)10 转换成 IEEE 754 单精度浮点数的二进制存储格式。
【解】
(22.78125)10 ＝(10110.11001)2
		  ＝(1.011011001)2×24
符号位 S＝0
阶码 e ＝指数＋(127)10＝(4＋127)10＝(10000011)2
尾数 f ＝(011011001)2
∴ 32位单精度浮点数的二进制存储格式为：
(0100 0001 1011 0110 0100 0000 0000 0000)2
＝(41B64000)16

【例2.18】对于下列每个 IEEE 754 单精度数值，解释它们所表示的是哪一种数字类型（规格化数、非规格化数、无穷大、0）。当他们表示某个具体数值时，请给出该数值。
0000 0000 0000 0000 0000 0000 0000 0000 b
0100 0010 0100 0000 0000 0000 0000 0000 b
1000 0000 0100 0000 0000 0000 0000 0000 b
1111 1111 1000 0000 0000 0000 0000 0000 b
【解】①  +0 （机器零）
②  +1.12×25＝1100002＝4810 （规格化数）
③  -0.12×2-126＝-2-12710 （非规格化数）
④  -∞ （负无穷大）

【例2.19】 float型数据通常用IEEE 754单精度浮点数格式表示。若编译器将float型变量x分配在一个32位浮点寄存器FR1中，且 x =-8.25，则FR1的内容是	。
	A．C104 0000 H 		B．C242 0000 H 
	C．C184 0000 H 		D．C1C2 0000 H


![|500](https://i.imgur.com/UouZVEf.png)

9.BCD码/8421码/余3码/格雷码
与数电内容一致，一带而过~

### 2.2  非数值数据的编码

本部分主要涉及计算机中的文字存储。

1. ASCII码
2. 汉字编码
- GB2312-1980		6763个汉字
- GBK			21003个汉字
- GB18030-2000		27484个汉字＋少数民族文字
3.区位码：1981年颁布。两个字节表示一个汉字，每个字节7位编码。将汉字和图形符号排列在一个94行、94列的二位代码表中，“区位码”（十进制编码）。
国标码＝(区位码)16＋2020H
汉字内码＝(国标码)16＋8080H

“春”字的机内码为 B4BAH，由此可推算它在GB2312-1980 中所在的区号是_____。
  A. 19区	  B. 20区  C. 3区	  D. 35区

### 2.3 检错与纠错码

1. 奇偶校验码
（1）一维奇偶校验
校验过程：将一个字X从部件A传送到部件B，采用偶校验。
发送端A：计算出校验位C，与要发送的数据合在一起，将（xn-1xn-2…x2x1x0C）发送到接收端B。
接收端B：接收到的是 X’＝ (x’n-1 x’n-2 … x’2 x’1 x’0 C’)，然后计算
若F＝1，收到的信息有错；
若F＝0，字X传送正确。

缺点：只能检测每个字中所产生的奇数个错误；不具备纠错能力
优点：开销小；常用于校验1字节长的数据：通常1字节长的数据编码发生错误时，1位出错的概率较大，两位以上同时出错的概率极小。
常用于：存储器读写校验，内存的存取过程，发生一位错的概率最大。电路简单、速度高、易于实现。按字节传输过程中的数据校验。

【例】已知大写英文字母“A”的 ASCII 码值为 41H，现字母“F”被存放在某个存储单元中，若采用偶校验（假设最高位为校验位），则该存储单元存放的十六进制数是_____。
A. 46H	B. C6H	C. 47H	D. C7H

（2）二维奇偶校验：垂直冗余检查VRC、纵向冗余检查LRC。

2. 循环冗余校验码：通过某种数学运算建立数据和校验位之间的约定关系。
- 编码及译码：
	- 发送端：被校验数据除以生成多项式；被校验数据减去余数，结果作为发送数据。
	- 接收端：接收数据除以生成多项式。可以除尽，编码正确；除不尽，余数指明出错位所在的位置。
- 采用模2算术运算：通过模2减法实现模2除；以模2加法的余数拼接在被校验数据的后面，形成能除尽的被校验数据。
- 生成多项式要求：任何一位发生错误都应使余数不为0；不同位发生错误应当使余数不同；应满足余数循环规律。
- 生成多项式的表示：如，生成多项式G＝$1011_2$，表示生成多项式为G(X)＝$X^3$＋X＋1
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/T38hzZZ.png" width="60%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/4fR96yh.png" width="60%" />
			</center>
		</td>
	</tr>
</table>
- (7，4)循环码编码、余数与出错位置的关系:
![|500](https://i.imgur.com/HxUxV2M.png)
其他常用生成多项式：CRC-12、CRC-16(ANSI)、CRC-CCITT(ITU-T) 、CRC-32

3. 海明码
主要用于存储器数据的校验与纠正。采用奇偶校验的原理，错误检测和校正能力随着信息字中加入奇偶校验位的数目线性增加。适用于最有可能发生随机错误的系统。
- 每一位的出错概率相同；
- 每一位与其它位是否出错没有任何关联。

（1）最小海明距离：两个编码字之间对应位置数值不同的位置数目称为两个编码字的海明距离。最小海明距离Dmin决定了该编码校验和纠正错误的能力。
- 任意编码字X如果被当作另外一个合法的编码字Y被接收的话，则在X中至少发生了Dmin个错误。
	- 要检测出k个(或少于k个)单位错误，所有合法编码之间就至少具有Dmin＝k＋1的海明距离。
	- 海明编码通常可以检测出Dmin-1个码位错误；
- 海明编码可以校正  （Dmin-1）/ 2个码位错误。
	- 要能校正k个错误，编码方案的最小海明距离必须大于2k＋1。

(2) 检错与纠错方法：r 位校验码可以区分出：“1个合法的编码字＋n个非法的编码字” (m＋r＋1)≤$2^r$
具体方法如下：
1. 先确定编码所需的校验位数目r，然后算出编码字的长度n，其中n＝m＋r。将编码字的各位从右向左排列，从1开始进行位置编号。
2. 编号是2的整数次幂的位置为奇偶校验位，其它位为数据位，按顺序填写。
3. 用如下方法确定某数据位应被哪些奇偶校验位所检测：第b位数据应被第b1、b2、…、bj位奇偶校验位所检测。其中，b1、b2、…、bj必为2的整数次幂，且b1＋b2＋…＋bj＝b。比如，位置编号为7（即b＝7）的数据，由于b＝1＋2＋4，则此数据位应被位置编号为1、2、4的奇偶校验位所检测。

【例 2.21】利用上述构造海明码的步骤，采用偶校验，对8位ASCII字符“M”进行编码（最高位为0）。人为地引入一个1位错误，说明如何找出这个错误。
【解】字符“M”的ASCII编码为01001101。
     ① 确定所需校验位的数目。
	数据位的位数m＝8，设校验位的位数为r，
	则根据不等式(m＋r＋1)≤2r，
	即(r＋9)≤2r，有r≥4。
	选择r＝4，则编码字共m＋r＝12位。
     ② 编码字：
![|400](https://i.imgur.com/JF0YM3C.png)
	③ 确定奇偶校验位的值：1＝1  2＝2  3＝1＋2  4＝4  5＝1＋4  6＝2＋4
7＝1＋2＋4  8＝8  9＝1＋8  10＝2＋8  11＝1＋2＋8  12＝4＋8
![|400](https://i.imgur.com/bvNL71q.png)
因此，“M”的编码字为：010011100101。

【例 2.21】利用上述构造海明码的步骤，采用偶校验，对8位ASCII字符“M”进行编码（最高位为0）。人为地引入一个1位错误，说明如何找出这个错误。
【解】在接收端，根据接收到的编码字求得校验方程Pi（i＝0～4），校验方程的编码值P(P＝P4P3P2P1P0)可作如下:
(1) 如果P各位全是0，则表示接收到的编码字中没有错误。
(2) 如果P中多位为1，则表示有一个数据位出错，且P的值即出错位在编码字中的位置。纠错时只需将出错位取反即可。
(3) 如果P中有且仅有一位为1，则表示某一校验位出错，不需要纠正。

接收端：如果接收到的编码字没有错误，接收到的编码字C’＝C＝010011100101，则
P0＝D6⊕D4⊕D3⊕D1⊕D0⊕H0＝1⊕0⊕1⊕0⊕1⊕1＝0
P1＝D6⊕D5⊕D3⊕D2⊕D0⊕H1＝1⊕0⊕1⊕1⊕1⊕0＝0
P2＝D7⊕D3⊕D2⊕D1⊕H2＝0⊕1⊕1⊕0⊕0＝0
P3＝D7⊕D6⊕D5⊕D4⊕H3＝0⊕1⊕0⊕0⊕1＝0
P＝P3P2P1P0＝0000，没有错误。

【解】接收端：如果接收到的编码字的数据位D5出错,接收到的编码字C’＝011011100101，则
P0＝D6⊕D4⊕D3⊕D1⊕D0⊕H0＝1⊕0⊕1⊕0⊕1⊕1＝0
P1＝D6⊕D5⊕D3⊕D2⊕D0⊕H1＝1⊕1⊕1⊕1⊕1⊕0＝1
P2＝D7⊕D3⊕D2⊕D1⊕H2＝0⊕1⊕1⊕0⊕0＝0
P3＝D7⊕D6⊕D5⊕D4⊕H3＝0⊕1⊕1⊕0⊕1＝1
P＝P3P2P1P0＝1010，
编码字的第十位(数据位D5 )发生错误，将该位取反即可纠错。

【解】接收端：如果接收编码字的校验位H2出错，接收到的编码字C’＝010011101101，则
P0＝D6⊕D4⊕D3⊕D1⊕D0⊕H0＝1⊕0⊕1⊕0⊕1⊕1＝0
P1＝D6⊕D5⊕D3⊕D2⊕D0⊕H1＝1⊕0⊕1⊕1⊕1⊕0＝0
P2＝D7⊕D3⊕D2⊕D1⊕H2＝0⊕1⊕1⊕0⊕1＝1
P3＝D7⊕D6⊕D5⊕D4⊕H3＝0⊕1⊕0⊕0⊕1＝0
P＝P3P2P1P0＝0100，
编码字的第四位(校验位H2)发生错误，无需纠错。


## 第三章   运算方法与运算器

本章主要介绍计算机内部的定点运算、算数逻辑部件（ALU等）及浮点数运算，主要是四则运算加减乘除的原理。

### 3.1  定点数运算 
1. 加减运算

（1）补码加减运算规则：
- 参加运算的操作数用补码表示；
- 补码的符号位与数值位同时进行加运算；
	- 加：两数补码直接相加；
	- 减：减数补码连同符号位一起按位取反，末位加1；再与被减数的补码相加。
- 运算结果即为和/差的补码。
![|400](https://i.imgur.com/plRx9Tn.png)
（2）溢出问题：当两个同符号的数相加（或者是相异符号数相减）时，运算结果可能发生溢出。
Q：如何防止溢出？ A：增加补码的二进制编码长度。
Q：如何判断是否发生了溢出？A：双符号位判决法；进位判决法；根据运算结果的符号位和进位标志判别；根据运算前后的符号位进行判别。

1) 双符号位判决法：若运算结果两符号分别用S2S1表示，则判别溢出的逻辑表示式为：VF＝S2⊕S1
     00 1000001  … 65
＋ 00 1000011  … 67    
     01 0000100  … 溢出                                             VF＝S2⊕S1＝1，发生溢出。

双符号位：
00：不溢出，结果为正；
11：不溢出，结果为负；
10：溢出，负溢；
01：溢出，正溢。

2) 进位判决法:若Cn-1为最高数值位向符号位的进位，Cn表示符号位向更高位的进位，则判别溢出的逻辑表示式为：
![|400](https://i.imgur.com/4Su6WAz.png)
3) 根据运算结果的符号位和进位标志判别 
适用于两同号数求和或异号数求差时判别溢出。溢出的逻辑表达式为：VF＝SF⊕CF

4) 根据运算前后的符号位进行判断
若用Xs、Ys、Zs分别表示两个操作数及运算结果的符号位，当两同号数求和或异号数求差时，就有可能发生溢出。
溢出是否发生可根据运算前后的符号位进行判别，其逻辑表达式为：
![|400](https://i.imgur.com/G9Gf6nn.png)
在CPU中，进行定点算术运算是否发生溢出，通常是由CPU中的硬件逻辑电路进行检测。一旦溢出发生，则会在CPU中的标志寄存器中建立溢出标志;或者产生溢出中断。

(3)1位/n位加法器的实现
1. 行波进位加法器
注：若一位全加器的进位延时为△t，则n位加法器的延时就是 n ·△t。
2. 先行进位加法器
3. BCD数加法器
注：BCD 加法的校正：
- 运算中某位BCD数(四位二进制数)相加的结果大于9或有向更高位的进位，则结果加6；
- 若不满足上述条件，则无需校正。

（4）移码加减运算
定点整数移码的加减运算的法则：
- 对两移码求和差时，首先对该两移码求和差；
- 对结果进行修正 —— 将结果的符号取反。

【例】机器字长为8位，
	[X]移＝10111001	     ……… 57
	[Y]移＝01011101	     …… －35
	求： [X＋Y]移， [X－Y]移。
	
【解】[X＋Y]补＝ [X]移＋[Y]移＝00010110
	因此，	     [X＋Y]移＝10010110
	[－Y]移＝ [[Y]移]求补＝10100011
	[X－Y]补＝ [X]移＋[－Y]移＝ 01011100
	因此，[X－Y]移＝ 11011100

2. 乘法运算
（1）原码乘法运算
1) 运算法则
- 乘积的符号为被乘数的符号位与乘数的符号位相异或；
- 乘积的绝对值为被乘数的绝对值与乘数的绝对值之积。即[X]原×[Y]原＝(X0⊕Y0 )(|X|×|Y|)

2) 实现思路与具体运算过程
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/D9kIcd4.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/J6mkMPf.png" width="90%" />
			</center>
		</td>
	</tr>
</table>

3) 原码二位乘法
![|400](https://i.imgur.com/nMLSy80.png)


（2）补码乘法运算
1) 校正法（其中：X0 、Y0为符号位 ）
假定被乘数X和乘数Y为用补码表示的纯小数：[X]补＝X0 . X-1X-2…X-(n-1) ，[Y]补＝Y0 . Y-1Y-2…Y-(n-1) 
公式：[X·Y]补＝[X]补(－Y0＋0.Y-1Y-2…Y-(n-1)) ＝[X]补(－Y020＋Y-12-1＋Y-22-2＋…＋Y-(n-1)2-(n-1)) 
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/oteRJsA.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/IqHMg1s.png" width="90%" />
			</center>
		</td>
	</tr>
</table>

2) booth法
1. 运算法则：
假定被乘数X和乘数Y为用补码表示的纯小数：[X]补＝x0 . x-1 x-2 … x-(n-1) ；[Y]补＝y0 . y-1 y-2 … y-(n-1) 
布斯法补码一位乘法的算法公式为：
[X·Y]补＝[X]补[(y-1－y0)20＋(y-2－y-1)2-1＋(y-3－y-2)2-2
					＋…＋(y-(n-1)－y-(n-2))2-(n-2)＋(0－y-(n-1))2-(n-1)] 
2. 运算规律
![|400](https://i.imgur.com/L3pbPNS.png)
3. 算法描述
- 乘数与被乘数均用补码表示，连同符号位一起参加运算；运算结果(乘积)也是补码。
- 乘数最低位后增加一个附加位(可用A-1表示)，初始设定为0。
- 从附加位开始，按上表总共进行n次加操作、n-1次右移操作(最后一次不右移)。
- 右移按补码规则进行，即符号位复制。
![|500](https://i.imgur.com/hVvn5bM.png)
3) 补码二位乘法*
补码二位乘法的法则：
- 乘数与被乘数均用补码表示，连同符号位一起参加运算。
- 乘数最低位后增加一个附加位(可用A-1)，初始设定为0。
- 从附加位开始，依据上表所示的操作规律，一次检测相邻3位决定具体的操作，并每次乘数右移2位。 
- 当乘数位数(包括符号位)为偶数n时，右移2位的次数为n/2次，最后一次只右移1位。
- 当乘数位数(包括符号位)为奇数n时，可在乘数最后一位之后添加一个0，使乘数位数变为偶数n+1，右移次数为(n+1)/2，且最后一次只右移1位；此时，也可以将乘数增加一个符号位，使乘数位数变为偶数n+1，右移次数为[(n+1)/2－1]。
Booth法改进，将Yi与Yi-1的状态比较和Yi-1与Yi-2的状态比较合在一起进行：
2(Yi-1－Yi)＋(Yi-2－Yi-1)＝Yi-1＋Yi-2－2Yi
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/JMWg9YW.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/DmkIX9o.png" width="90%" />
			</center>
		</td>
	</tr>
</table>

（3）阵列乘法器/适用于流水线的阵列乘法器

3. 除法运算
（1）原码除法
1. 前提条件：
	- 除数≠0；
	- 定点纯小数时，|被除数|＜|除数|；
	- 定点纯整数时，|被除数|≥|除数|。
2. 商的符号＝被除数的符号⊕除数的符号
3. |商|＝|被除数|÷|除数|
4. 将商的符号与商的值拼接在一起。
![|500](https://i.imgur.com/RVKgQyE.png)
5. 恢复余数法
定点纯小数：
- 符号位单独处理。
- 被除数左移一位，减除数，
	- 若够减，上商为1；
	- 若不够减，上商为0，同时加除数(恢复余数)。
- 余数左移一位，减除数，
	- 若够减，上商为1；
	- 若不够减，上商为0，同时加除数(恢复余数)。
- 重复上面的过程直到除尽或精度达到要求。
- 拼接商符得到商。
- 特点：不同的被除数和除数，其除的过程不规范，何时需恢复余数是不相同的，实现起来不便于控制。

【例】被除数 X＝－0.10001011；除数 Y＝0.1110；利用原码恢复余数法求商及余数。
【解】前提条件：|X|＜|Y|，|Y|≠0。[X]原＝1.10001011。[Y]原＝0.1110；商符＝1⊕0＝1
绝对值除法过程：
![|500](https://i.imgur.com/ahPPKkw.png)

6. 加减交替法
加减交替法的运算法则：
- 若余数R≥0, 则商上1，余数左移一次，减除数；
- 若余数R＜0, 则商上0，余数左移一次，加除数。
![|500](https://i.imgur.com/oep71zJ.png)

（2）补码除法
- 先决条件：
	- 定点纯小数
	- 除数≠0
	- |被除数|＜|除数|
- 补码除法的法则：
	- 如果被除数与除数同号，被除数减除数；如果被除数与除数异号，被除数加除数。运算结果称为余数。
	- 若余数与除数同号，上商为1，余数左移一位，下次用余数减除数操作求商；若余数与除数异号，上商为0，余数左移一位，下次用余数加除数操作求商。
	- 重复2，直至除尽或达到精度要求。
	- 商修正。在除不尽时，通常可用商的最低位恒置1进行修正来保证精度。
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/bfslwMF.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/I8AlkQH.png" width="90%" />
			</center>
		</td>
	</tr>
</table>

【例】X＝－0.10001011；Y＝0.1110；利用补码除法求商及余数。
【解】[X]补＝1.01110101；[Y]补＝0.1110；[－Y]补＝1.0010
![|500](https://i.imgur.com/HqKtrWS.png)
（3）阵列除法器
1. 补码运算进位：在做无符号数减法时，用被减数＋[减数]求补 来实现。
- 若被减数＜减数(不够减)，没有进位(借位)；
- 若被减数＞减数(够减)，有进位(借位)。
2. 基本元器件：可控加减单元CAS


### 3.2 算数逻辑器件
1. 寄存器/计数器
2. 算数逻辑器件
74LS181（4位ALU） -> 由74181构成组间串行进位的16位ALU（组内先行进位，组间串行进位）
3. 运算器的结构
1) 三种基本结构特点：
- 总线总是分时工作的，任何时侯只允许一个器件将其信号输出加到总线上。多于一个器件必然引起总线竞争。
- 同一个功能部件一次只能做一件事。
- 在双总线及三总线结构的运算器中需要多端口器件。
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/gZ9IkAZ.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/x8fgAfN.png" width="90%" />
			</center>
		</td>
	</tr>
</table>



### 3.3 浮点运算

1. 加减运算

设两个浮点数：$X=M_x·2^{Ex}$，$Y=M_y·2^{Ey}$
实现X±Y运算的法则：
1. 对阶  (小阶对大阶：小阶码＋1，尾数右移1位，直到增大到与大阶码相同)
2. 尾数加(减)运算   (加法；减法：减数的符号取反(求补)，与被减数相加。)
3. 规格化
	- 左规  
	   运算结果尾数为：
		- 11.1xx…x 或 00.0xx…x：尾数每左移1位，阶码减1，直到使尾数成为规格化数为止。
		- 阶码减1，必须同时判断是否下溢。若发生下溢，可认为结果为0。
	- 右规
      若结果(尾数)发生溢出，即结果出现10.XX…X 或01.XX…X 时：
		- 尾数右移1位，阶码加1。右规最多1次。
		- 阶码加1，必须同时判断是否上溢。若发生上溢，可认为结果为∞。
4. 舍入处理（对阶、规格化时，右移操作后，需进行舍入处理）
	- 截(尾)断法（将需丢弃的尾数低位丢弃）
	- 末位恒置1法（使要保留的尾数的最低位永远为1）
	- 0舍1入法
		- 当尾数右移丢弃的是1时，要保留的尾数最末位加1；
		- 当尾数右移丢弃的是0时，要保留的尾数最末位不变。
		- 当遇到01.111…11这种需右规的尾数时，采用此法会再次使尾数溢出。遇到这种情况可采用截尾法。

假定X、Y、Z为浮点数，Z＝X＋Y 或 Z＝X－Y，浮点数加(减)法流程：
![|500](https://i.imgur.com/z8ujcND.png)
【例3.22】两浮点数的和、差。
X＝0.110101×$2^{-010}$；Y＝－0.101010×$2^{-001}$。
【解】阶码4位，补码表示；尾数8位，双符号位补码表示。两数可表示为：
[X]浮＝1110; 00.110101
[Y]浮＝1111; 11.010110
① 对阶
求阶差：[△E]补＝[EX]补＋[－EY]补＝1110＋0001＝1111
X的阶码比Y的阶码小。 X尾数右移一位，使两者阶码相同
[X]’浮＝1111; 00.011010(1)
[Y]浮  ＝1111; 11.010110
② 尾数求和/差：
③ 规格化
④ 舍入处理：
![|500](https://i.imgur.com/LSqtVpY.png)


2. 乘除运算

设 X、Y、Z 为浮点数，$X=M_x·2^{Ex}$，$Y=M_y·2^{Ey}$，$Z=X*Y=(M_xM_y)2^{E_x+E_y}$
两浮点数相乘之积的阶码为两乘数阶码之和；尾数为两乘数尾数之积

浮点乘法的运算过程：
1. 两乘数一定是规格化数。若有一个乘数为0，则乘积必为0。（0操作数检查）
2. 求乘积的阶码： Ez＝Ex＋Ey；判断积的阶码是否溢出：上溢、下溢。（阶码加）
3. 求乘积的尾数：两乘数的尾数相乘。（尾数乘）
4. 规格化乘积的尾数。（结果规格化、舍入）
- 若尾数为n位补码(含1位符号)，则规格化正数范围：＋1/2～＋(1－2-(n-1))；负数范围：－1～－(1/2+2-(n-1))。
- ∵ |两规格化数之积|≥1/4，∴ 积的尾数若需左规，只需1次左移。
- 积有可能为＋1，需右规。只需1次右移，并采用某种舍入算法。

设 X、Y、Z 为浮点数，$X=M_x·2^{Ex}$，$Y=M_y·2^{Ey}$，$Z=X \div Y=(M_{x} \div  M_y)2^{E_x-E_y}$
两浮点数相除，商的阶码＝被除数的阶码－除数的阶码；尾数＝被除数的尾数÷除数的尾数

浮点除法的运算过程：
1. 被除数、除数一定是规格化数，除数≠0。若被除数为0，则商必为0。（0操作数检查）
2. 求商的阶码： Ez＝Ex－Ey；判断商的阶码是否溢出：上溢、下溢。（阶码减）
3. 求商的尾数：Mz＝Mx÷My（尾数除）
4. 规格化商的尾数。（结果规格化、舍入）
- 若尾数为n位补码(含1位符号)，则规格化正数范围：＋1/2～＋(1－2-(n-1))；负数范围：－1～－(1/2+2-(n-1))。
- 商可能的绝对值最小的尾数：(1/2)÷(－1)＝－1/2，需要左规，只需左移1次。
- |被除数尾数|＞|除数尾数|，产生整数商。需要右规，只需右移1次，并采用某种舍入算法。
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/jiZMM3i.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/Whwhhk7.png
" width="90%" />
			</center>
		</td>
	</tr>
</table>

【例】两规格化浮点数，阶码用移码、尾数用原码表示。 
① 两浮点数求和、差，最后对结果规格化时，能否确定需要右规的次数？能否确定需要左规的次数？
② 两浮点数相乘，是否可能需要右归？是否可能需要左规？为什么？若需要，能否确定左规、右归的次数？
③ 两浮点数相除，是否可能需要左归？是否可能需要右归？为什么？若需要，能否确定右规、右归的次数？
【解】
①两个n位数相加、减，其和、差最多为n+1位，因此有可能需要右规，但右规最多一次。
    由于异号数相加，或同号数相减，其和、差的最少位数无法确定，因此左规的次数也无法确定，但次数最多不会超过尾数的字长，即n次。
②规格化浮点数相乘时，只有当两个浮点乘数的尾数均为-1时才需要右规。因为(-1)×(-1)=1，-1为规格化数，而+1不是，所以需要右规一次，使尾数成为+1/2。
    规格化浮点数相乘时需要左规。规格化尾数的范围为：1/2≤|M|≤1，其积的范围为：1/4≤|积|<1，因此最多左规一次。
③规格化浮点数相除时，只有一种情况需要左规，即当被除数的尾数为1/2、除数的尾数为-1时，需要左规。因为(1/2)/(-1)=-1/2，1/2和-1均为规格化数，而-1/2不是，所以需要左规一次，使尾数成为-1。
    规格化浮点数相除时，被除数、除数均为规格化数，规格化尾数的范围均为：1/2≤|M|≤1，所以商的绝对值范围为：1/2≤|商|<2。因此需要右规，但最多右规一次。

3. 浮点运算的实现：软件方法；配专用浮点处理器；在处理器中设置浮点运算部件；浮点运算的流水线处理。


## 第四章   存储系统

本章主要涉及存储系统的概述，并具体介绍Cache和主存储器的机制，最后介绍虚拟存储器与外存储器的知识。

### 4.1 存储系统概述

存储系统：将两种或两种以上的存储器用硬件，软件，或硬件和软件相结合的方式联接在一起，并对它们进行管理。
一般计算机系统中主要有两种存储体系：
Cache存储体系：由Cache和主存储器构成；主要目的是提高存储器速度。（对系统程序员以上均透明）
虚拟存储体系：由主存储器和磁盘存储器构成；主要目的是扩大存储器容量。（对应用程序员透明）

存储器的分类标准
- 存储信息的介质：半导体、磁盘、磁带、光盘
- 在计算机中的用途：主存储器(内存)、高速缓冲存储器(Cache)、控制存储器、外存（磁盘/光盘/闪盘/SD存储卡/磁带）
- 存放信息的易失(挥发)性：易失：RAM；非易失：ROM、磁盘、……
- 存取方式：随机读写：RAM；顺序(串行)访问：顺序存取存储器 SAM、直接存取存储器 DAM
注意：存储器的存取时间与存储单元的物理地址无关，随机读写其任一单元所用的时间一样。
- 读写功能：读写存储器、只读存储器

存储器的性能指标
- 容量
- 速度
	- 存取时间(访问时间)：对存储器中某一个单元的数据进行一次存(取)所需要的时间。
	- 存取周期：连续对存储器进行存(取)时，完成一次存(取)所需要的时间。
	- 存储器带宽：单位时间里存储器可以读出(或写入)的字节数。
- 可靠性（可维修部件的可靠性：平均故障间隔时间（MTBF）；不可维修部件的可靠性：平均无故障时间/平均故障前的时间（MTTF））
- 功耗
- 价格
- 体积、重量、封装方式、工作电压、环境条件

### 4.2 内存储器
1. 随机读写存储器（RAM）
（1） 内部译码结构
某芯片容量为64KB，地址线A0～A15。
一维译码，译码输出：65536条
二维译码，译码输出：256行＋256列
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/ARlE34d.png" width="60%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/PFILude.png" width="60%" />
			</center>
		</td>
	</tr>
</table>
（2）单元电路
1)  静态读写存储器SRAM
特点：
- n个这样的电路可构成n位存储单元。
- 只要不断电，信息一直保持。
- 初始加电，状态随机。
- 电路中总有晶体管导通，功耗大，集成度不高。
- 引脚：地址线，数据线，读信号，写信号，片选。

2) 动态读写存储器DRAM
特点：
- n个这样的电路可构成n位存储单元。
- 必须定时刷新。
- 初始加电时，状态随机。
- 在不进行读写及刷新时，电路中无晶体管导通：功耗低，集成度高

SRAM和DRAM电路结构图如下：
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/E6ukM6W.png" width="60%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/Hf0Shcn.png" width="60%" />
			</center>
		</td>
	</tr>
</table>

（3）主存储器的组成及接口
1. 需要注意存储器与CPU速度上的协调。在选芯片时应留有30％的余量。且快速的CPU使用慢速的存储器时，需要采取措施。
2. 内存构成——芯片与总线连接示例：
![|300](https://i.imgur.com/Wpn1eX8.png)

3. 内存构成——内存的字扩展
4. 内存构成——内存的位扩展
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/NcvicQm.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/mJgGRy3.png" width="90%" />
			</center>
		</td>
	</tr>
</table>
5. 80x86内存的连接
① 8086的内存接口
8086 CPU是16位处理器。系统总线的数据线16位，即 D0～D15。内存奇偶分体。
![|400](https://i.imgur.com/4zgmqzM.png)
![|600](https://i.imgur.com/gRCTwET.png)

（4） 只读存储器（ROM）
1. 特点：存储信息的非易失性。
2. 分类：
- 掩膜型ROM（成本低）
- 可编程ROM（可一次性编程）
	- PROM、OTP-ROM
- 可擦可编程ROM
	- EPROM
	- E2PROM：并行、串行
	- 闪速(Flash)存储器
		- 或非型（NOR）阵列
		- 与非型（NAND）阵列 

（5）动态存储器（DRAM）
1. 特点：**地址需分两次送**（地址线根数减半，相对来说，行数可以少列数可以多。如19=9+10），需要定时刷新（**以行为单位**）。集成度高。
2. 常用的刷新方式：集中式（**存在死区**），分散式（分布式）（**无死区，但存取周期变长，效率更低**），异步式（常用，死区较小，若安排在**指令译码阶段将不存在死区**。）。

（6）同步动态存储器（SDRAM）
1. **支持突发读写**（典型的突发的长度是8）。 DDR SDRAM（双倍速）
2. 应用于主存。

（7）主存储器校验
1. 多端口存储器（多端口不允许同时对同一单元写->改进方法）->主要用于并行访问内存/多机系统/CPU内部/Cache
2. 多体交叉存储器->类似**流水线**，加速比与**转移概率**有关。->主要是主存：SDRAM内部（微观）、多通道的主存（宏观）
3. 相连存储器（按内容查找）->**容量不能太大**，硬件复杂度会太高。->主要用于Cache的目录表/虚拟存储器的快表


### 4.3 高速缓冲存储器（大题）
1. 引入依据与工作原理
- 引入依据：程序和数据的局部性原理（时间、空间）->主要是循环中：循环变量为时间局部性，数组元素为空间局部性。
- 工作原理：主存物理地址->Cache内部地址->访问数据送给CPU（理想情况）

![|500](https://i.imgur.com/i0M5jPD.png)


注意：
1. **主存与Cache交换数据以块**（Line、行，常见为**64字节为一块**。）**为单位**，不是以字节/字为单位。若有剩余，直接装即可。若Cache满了，则只能替换掉某一块（Cache替换策略->若没被CPU修改可以直接替换，若被CPU修改还需要将其写回主存原来的位置，还需要修改目录表）。
2. 64字节为一块的原因/多体交叉存储器的应用：
1) 多体交叉存储器在SDRAM内部的实现原理相符 
2) SDRAM支持突发读写（CPU在读写内存条时，一次可以读写64位二进制数/8个字节） 也就是说，送一次行列地址之后可以连续访问8个数据，每个数据又是8个字节64位，故总共64个字节。故一次突发读写刚好可以读64个字节，设计Cache为64的访问效率即为最高。

2. 主存(一般为SDRAM)与Cache的地址映射/地址变换
1) 全相联（完全自由）
![|500](https://i.imgur.com/usRSZSi.png)

- 注：通常目录表容量比Cache容量小。
- 映射规则：主存的任意一块可以映象到Cache中的任意一块。
- 特点：
	- 块冲突概率低，Cache空间利用率高。
	- 相联目录表容量大→成本高、查表速度慢。

2) 直接映射
![|500](https://i.imgur.com/tJQ3sWc.png)

- 映射规则：主存的每一块只能映象到Cache的一个特定的块中。
- 整个Cache地址与主存地址的低位部分完全相同。
- 优点：
	- 硬件简单，不需要相联存储器，只要
		- 容量较小的按地址访问的区号标志表存储器；
		- 少量外比较电路。
	- 访问速度快（无需地址变换）。
- 缺点：
	- Cache块冲突概率高；
	- Cache空间利用率很低。

3) 组相连
![|500](https://i.imgur.com/KUd6jKP.png)
- 若直接给出主存地址，可以用主存总容量除以区的容量，得到区号：如本题区号：$2^{10}/2^8$ 即可得到。
- 目的：减小相联目录表的容量，降低成本，提高地址变换速度。
- 映射规则：将主存和Cache都机械等分成相同大小的块，并将主存空间按照Cache大小等分成区，再将Cache和主存空间中的每一区都等分成大小相同的组，让主存各区中的某组中的任何一块均可直接映象装入到Cache中对应组的任何一块上。从主存的组到Cache的组之间采用直接映象方式，在两个对应的组内部采用全相联映象方式 ——组间直接，组内全相联。
- 优点：
	- 块的冲突概率比较低；
	- 块的利用率大幅度提高；
	- 块的失效率明显降低。
- 缺点：实现难度和造价比直接映射方式高。

3. 对应例题：

例1：
- 注意：主存容量可以改为“最大寻址空间为1MB”
- 做题第一步：**主存地址的划分**：区号+块号+块内地址（直接映射），并确定各字段位数。
- 区号以外的块号+块内地址部分，**即为Cache容量**。块内地址部分即为“按XXX分块”，主存地址的总位数为“主从容量为XXXX”
- 若主存不分区，直接把区号+块号转化为对应十进制数的二进制数。（如1.1中 129转化为10000001，则块号为0001（1），区号为前面部分（8），即主存第8区第1块）。当然，也可以按图中所给的方法除法分析求解。
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/UPpxuPW.png" width="95%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/D4q2pL1.png" width="95%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/oGpQpxd.png" width="95%" />
			</center>
		</td>
	</tr>
</table>


例2：
- 实际上，目录表前4位不需要存储。
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/HFev7YZ.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/iT4NAXX.png" width="90%" />
			</center>
		</td>
	</tr>
</table>


例3：
- 目录表转化为二进制形式，分析更方便。
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/oZ2OPDS.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/lwFRTCG.png" width="90%" />
			</center>
		</td>
	</tr>
</table>

4. Cache中需要存储的其它信息：
- 有效位（一位）
- 修改位（**写回法**）-> dirty bit
- 计数器（替换策略）
- **不需要存储行号**（行号最高位即为组号，行号低两位即为组内块号）

5. 替换算法
- 直接映射不需要替换算法。
- **全相联、组相联**：
	- 随机算法（RAND, Random Algorithm）
	- 先进先出算法（掌握） (FIFO, First-in First-out Algorithm)
		- 利用了历史信息
		- 没有反映局部性——最先调入的，可能也是要使用的。
	- 最不经常使用算法(LFU, Least Frequently Used Algorithm)：计数器位数多，实现困难。
	- **近期最少使用算法**（掌握） (LRU, Least Recently Used Algorithm)：多/少有/无。替换近期最久未用的块。
	- 最佳替换算法(OPT, Optimal replacement algorithm)
- 目前CPU常用“**两路组相联**”。在实现LRU时，增加一个二进制位即可记录。
- 例：若为四路组相联的情况，如图所示：
![|500](https://i.imgur.com/rTx1riE.png)
6. Cache的一致性问题
- 写回法（常用）
	- Cache命中 → 只修改Cache → Cache中该块需替换，则才写回主存（**在替换前的这段时间里面，存在主存和Cache内容不一致的问题**）。
	- Cache不命中 → 该块从主存拷贝至Cache
- 全写法（写直达法）
	- Cache命中 → 写Cache，同时写主存（一致性好）。
	- Cache不命中 → 直接写主存 
	- 缺点：每次需要修改Cache和主存，速度较慢
- 主要问题：I/O经过DMA的方式直接读取主存并交换数据，可能存在问题
- 解决方法：
	- 直接将主存的缓冲区设置为不可缓存。
	- 操作系统精确控制，执行和Cache管理相关的指令。
	- 对于多处理器系统（多核），Cache之间存在通信线路（单独的总线传递消息）->MESI协议
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/iqnqtKg.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/c4Dr8sW.png" width="90%" />
			</center>
		</td>
	</tr>
</table>

7. Cache的性能分析
1) 加速比
![|500](https://i.imgur.com/XC0LfRf.png)
2) 成本(单位容量价格)
![|500](https://i.imgur.com/fDIEBjn.png)
3) 命中率与Cache的关系/命中率与块大小的关系/两级Cache/**多级Cache**

【例】10000次访存，第一级Cache失效400次，第二级Cache失效4次。
- (失效率)第一级＝400/10000＝4％
- (失效率)第二级＝4/400＝1％
- 利用两级Cache后总的失效率＝0.04％。


### 4.4 虚拟存储器

1. 基本概念
![|500](https://i.imgur.com/XCyhNMl.png)
- 起因：
	- 高速的主存容量满足不了要求（主要原因：**提高主存容量**）
	- 多道程序运行→各程序独立编址→程序再定位   “逻辑地址→实际地址”（**解决程序再定位问题**）
- 其中，虚拟存储体系为主存与磁盘间的存储体系。操作系统（OS）负责段表/页表的建立与维护，主存页与磁盘的来回交换。地址变换由CPU内部的硬件（MMU管理）。**应用软件不需要参与**。
- 虚拟存储器：主存储器＋联机工作的外部存储器＋辅助硬件（MMU）＋系统软件，对于程序员，可看作一个单一的存储器 —— 速度、容量、每位价格
- 虚拟存储器中有三种地址空间：
	- 虚拟地址空间：程序员编程中用到的地址。→ 编译程序生成  （软件用）
	- 主存储器地址空间：实际主存的物理地址。→ CPU地址引脚   （以页的形式存储在这）
	- 辅存地址空间：磁盘存储器的地址。  （暂时不用的）
		- 地址映象：把虚拟地址空间映象到主存地址空间。即把用户按虚拟地址编写的程序按照某种规则装入主存储器，并建立多用户虚地址与主存实地址之间的关系。(**映像方式：全相联，选择LRU算法**)
		- 地址变换：在程序运行时，把虚地址变换成主存实地址。（**MMU操作**）
- 因**地址映象和变换方法**不同，有三种虚拟存储器：段式虚拟存储器、页式虚拟存储器、段页式虚拟存储器。（主要指主存与磁盘之间交换单位的方式）

2. 段式虚拟存储器
- 段式存储管理方式：将程序按逻辑意义分成段，按段进行调入、调出和管理。
- 地址映象方法：每个程序段都从0地址开始编址，长度可长可短，可以在程序执行过程中动态改变程序段的长度。
![|500](https://i.imgur.com/pwFnZJh.png)

- 地址变换方法：
	1. 由用户号找到基址寄存器；
	2. 从基址寄存器中读出段表的起始地址；
	3. 把起始地址与多用户虚地址中段号相加得到段表地址；
	4. 把段表中给出的起始地址与段内偏移D相加就能得到主存实地址。
![|500](https://i.imgur.com/Yxnj844.png)

- 主要优点：
	- 程序的模块化性能好。
	- 便于多道程序共享主存中的某些段。
	- 程序的动态链接和调度比较容易。
	- 便于按逻辑意义实现存储器的访问方式保护。
- 主要缺点：
	- 地址变换所花费的时间长，两次加法。
	- 段映象表庞大，地址、段长字段太长。
	- 主存储器的利用率往往比较低——存储管理复杂；段间“零头”。
	- 对辅存（磁盘存储器）的管理比较困难。
- 目前的实际情况：段表基址寄存器只有一个，用户号也不需要存储。
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/fG4ys8r.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/YgaoNh3.png" width="90%" />
			</center>
		</td>
	</tr>
</table>


3. 页式虚拟存储器（最常用）
- 4K对齐：地址除以4K的话，余数应该为0。
- 虚页号对应行号。
- 现采用多级页表的方式。
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/ZoBBpIQ.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/bmiDQyV.png" width="90%" />
			</center>
		</td>
	</tr>
</table>

4. 段页式虚拟存储器
- 地址映象方法：每个程序段在段表中占一行， 在段表中给出页表长度和页表的起始地址，页表中给出每一页在主存储器中的实页号。
- 地址变换方法：
	- 先查段表，得到页表起始地址和页表长度；
	- 再查页表找到要访问的主存实页号；
	- 把实页号p与页内偏移d拼接得到主存实地址。
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/i9514e8.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/YBmIGe7.png" width="90%" />
			</center>
		</td>
	</tr>
</table>
- 注意：主存与磁盘之间交换信息的单位：段式：段。 页式/段页式：页。

5. 多级页表
- 需要设置的级数
- 注意向上取整
![|500](https://i.imgur.com/hQJwu0N.png)


6. 虚拟存储器地址变换带来的速度问题
- 快慢表法
	- 查表时，由虚页号**同时查快表和慢表**，如果在快表中找到，则立即使慢表查找作废。如果在快表中查不到，则经过一个访主存时间，从慢表中查到实页号，并将其送入主存实地址寄存器，同时将此虚页号和对应的实页号送入快表 —— LRU替换算法。
	- 快表：快表(TB)，或 变换旁视缓冲器(TLB)  **TLB** —— Translation Lookaside Buffer
		- 小容量（几～几十个字）；
		- 高速硬件实现；
		- 采用相联方式访问。
	- 慢表：
		- 当快表中查不到时，从主存的慢表中查找；
		- 慢表按地址访问，用软件实现。
		- 快表与慢表也构成一个两级存储层次。
	- 主要存在问题：
		- 相联访问实现困难，大容量速度低
- （相联）目录表法
	- 地址变换过程：把多用户虚地址中U与P拼接，相联访问目录表。读出主存实页号p，把p与多用户虚地址中的D拼接得到主存实地址。如果相联访问失败，发出页面失效请求。
	- 主要优点：与页表放在主存中相比，查表速度快。
	- 主要缺点：可扩展性比较差，主存储器容量大时，目录表造价高，速度低。


7. 虚拟存储器实例：Pentium（老的，199几年的）
- flat内存模型
- 保护模式下的分段/分页管理

8. 页式虚拟存储器的工作过程
![|500](https://i.imgur.com/38vEFUd.png)

### 4.5 外存储器

1. 磁表面存储器
1) 磁记录原理与磁记录方式/性能评价
- 巨磁电阻效应（GMR：Giant Magnetoresistance）：在通有电流的多层磁性金属或合金上施加磁场时，其电阻值将发生明显变化。
- 不归零制无自同步能力
- 编码效率η ＝ 位密度/最大磁化翻转次数  **改进调频制**最好。

2) 磁盘存储器概述：
1. 磁盘结构：硬盘
2. 硬盘的数据记录格式
- 内部物理地址：CSH（柱面磁道Cylinder，记录面磁头Head，扇区Sector）
- 扇区的编号方法：连续编号，间隔编号
- 磁道的起始位置：索引
- 扇区－记录块
- （希捷 ST-506 超级老的硬盘 ）原理图
![|500](https://i.imgur.com/kFEGHpS.png)

3. 主要技术指标
- 道密度：道/mm，道/英寸
- 位密度：bit/mm，bit/英寸，最靠近盘中心的磁道
- 每个磁道划分的扇区都一样。（西电教材）-> **外圈扇区可靠度最高**
- 存储容量
	- 非格式化容量＝位密度×内圈磁道周长    ×每个记录面的磁道数×记录面数
	- 格式化容量＝每个扇区的字节数×每道的扇区数    ×每个记录面的磁道数×记录面数
- 平均访问时间＝平均寻道时间＋平均等待时间＋数据传输时间
	- 寻道时间：磁头移动到目标磁道(或柱面)所需要的时间，一般几ms～10ms。
	- 等待时间：待读写的扇区旋转到磁头下方所用的时间，一般选用磁盘旋转一周所用时间的一半作为平均等待时间，在1ms～6ms之间。
- 转速：RPM（转/分钟）5400RPM，7200RPM，10000RPM，15000RPM
- 数据传输率：磁头找到数据的地址后，单位时间内写入或读出的字节数。＝每个扇区的字节数×每道扇区数×磁盘的转速
- 硬盘内部的高速缓存大小、采用的接口、……
- 文件在硬盘上存储时应尽可能放在同一柱面上，或者放在相邻柱面上，这样可以缩短寻道时间。

4. 连接框图
![|500](https://i.imgur.com/vi8zARa.png)

3) 磁盘参数计算
【例】某硬磁盘有5个记录面，记录面上有效记录区域的内径为20cm，外径为30cm。磁道上记录的位密度为250b/mm，道密度为10道/mm，每一磁道上分为16个扇区，每个扇区记录1KB，磁盘旋转速度为10000rpm；则：
该硬盘的非格式化容量为_______MB，格式化容量为_______MB，该硬磁盘的数据传输速率为_________MB/s。
- 1K =$2^{10}$  1M=$2^{20}$  1G=$2^{30}$ (衡量存储器的容量)
【解】磁道数＝(300/2－200/2)mm×10道/mm＝500道；
每磁道的非格式化容量＝(π· 200mm)×(250/8)B/mm
                                        ＝3.14159×200×250/8 ＝ 19635B；
每磁道的格式化容量＝16扇区×1KB/扇区＝16KB；
非格式化容量＝5面×500道×(19635/$1024^2$)MB≈47MB；
格式化容量＝5面×500道×(16/1024)MB≈39MB；
数据传输速率＝(10000道/60s)×(16/1024)MB≈2.60MB/s 。

4) 磁盘阵列
- 辅存性能的改进速度比处理器和主存慢得多。
- 如果一种部件只有一点进步，那么，并行使用多个部件会获得意外的性能。增加磁盘的可靠性、成本。本质目的：**提高可靠性+提高特性**
- RAID：独立冗余磁盘阵列（由独立的磁盘组成的具有冗余特性的阵列）（Redundant Array of Inexpensive Disks/Redundant Array of Independent Disks）
	- RAID0，RAID1，RAID2，RAID3（不支持并发IO），RAID4（校验盘争用问题），**RAID5（最流行）**

### 补充1  Cache一致性协议MESI

MESI：四种状态（修改态，独占态，共享态，无状态）
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/9p5useF.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/vbiaWQm.png" width="90%" />
			</center>
		</td>
	</tr>
</table>
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/CAG3BW5.png" width="95%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/OLQtqRb.png" width="95%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/O1MXiSg.png" width="70%" />
			</center>
		</td>
	</tr>
</table>
**总的状态转移图**：
![|500](https://i.imgur.com/B4uantN.png)


### 补充2  Cache的实现

来自于《计算机体系结构——量化研究方法》
实例：第四版的AMD 皓龙处理器
- 地址划分也有分为：Tag、Index和按位地址，即标记字段，索引字段和按位地址。
- 具体的示意图如下：
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/hVsOFZ0.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/T7mTRbI.png" width="90%" />
			</center>
		</td>
	</tr>
</table>
- 特殊情况：
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/uyn08av.png" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/WBUluo5.png" width="90%" />
			</center>
		</td>
	</tr>
</table>


### 补充3  存储体系的实现

![|500](https://i.imgur.com/PTPRmok.jpg)

- 用来存储常用的虚页号和实页号之间关系的高速缓存，称为TLB。
- 建立新的页表，修改页表：flush（清除） TLB  .  可用如下类似指令:
	- MOV RAX，CR3
	- MOV CR3，RAX
- 也可以用ASID编号区分
	- 通常情况下，进程ID取值范围很大，ASID仅有8-16位
![|600](https://i.imgur.com/FWrDXMt.png)

- Intel I7 6700
![|600](https://i.imgur.com/5DMA1H3.png)



## 第五章 指令系统

### 5.1 指令系统概述

- 指令系统的设计主要包括指令的功能（操作类型、具体操作内容）和指令格式的设计。
- 指令系统的评价：完备性，高效性，规整性，兼容性。
- 指令的基本格式：
![|500](https://i.imgur.com/SvLidhu.png)


### 5.2 指令系统结构层定义

1. 数据存储顺序
- **不管是大端存储还是小端存储，都用最小的地址表示数据的地址**。
- 大端存储（Big-Endian Ordering）最低有效字节存储在最高地址位置
- 应用于IBM S370/390、Motorola 680x0、大部分RISC
- 优点：
	- 字符串分类
	- 十进制/ASCII字符打印
	- 一致的次序：整数和字符串

- 小端存储（Little-Endian Ordering）最低有效字节存储在最低地址位置
- 应用于Intel 80x86、Pentium、VAX、Alpha
- 优点：
	- 整数地址转换
	- 算术运算


【例】32位的十六进制数据12345678H，在以字节编址的主存空间4000H开始位置存储：
![|500](https://i.imgur.com/2cEy1Nc.png)

【例】对下列数据结构，给出数据在以字节编址主存中以大端和小端方式存储的位置情况。（32位机）
- 西电版P176, 习题5.14 / 高教版P221, 习题5.8
```C
struct {
   double i;     //0x1112131415161718
} s1;

struct {
   int i;     //0x11121314
   int j;     //0x15161718
} s2; 

struct {
   short i;	//0x1112
   short j;	//0x1314
   short k;	//0x1516
   short l;	//0x1718
} s3;
```
<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/F6qJ7Vp.png" width="95%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/W3ND8tz.png" width="95%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/cLTpGUj.png" width="95%" />
			</center>
		</td>
	</tr>
</table>

2. 边界对齐
- 不对齐也没事，但会影响性能。
![|500](https://i.imgur.com/FMJm3mP.png)
3. 堆栈（实际是数据结构的栈，后入先出）
- 堆栈的典型应用：
	- 作为临时存储区域
	- CALL指令，保存返回地址
	- 调用过程时，传递参数
	- 过程内的局部变量
![|500](https://i.imgur.com/ayFfNqX.png)

4. 冯·诺依曼结构和哈佛结构
- 哈佛结构的优点：
	- 指令存储器只读，设计、控制简单；
	- 避免了数据对程序可能造成的破坏；
	- 利用n位地址可以获得2个2n大小的地址空间。
	- 目前大多数RISC系统采用哈佛结构。
- 目前常用：内部哈佛结构，外部冯诺依曼结构。



### 5.3 指令功能的设计

1. 指令功能的角度：
![|500](https://i.imgur.com/eOni2pT.png)
- 输入输出类指令：
	- 存储映射的编程控制I/O方式：统一编址(RISC（Arm）)
		- MOV 指令
	- 分立的编程控制的I/O方式：独立编址(X86)
		- IN 指令
		- OUT 指令

2. 寻址方式

- 寻址方式：
	- 指令获取操作数的方式。
	- 规定如何对地址码字段做出解释以找到所需操作数的方式；或 程序转移时找到转移地址的方式。
- 寻址方式设计要考虑：
	- 能够有效压缩地址码字段的长度；
	- 能够支持灵活的程序设计。
- 寻址方式在指令中的体现：
	- 由操作码决定 —— 隐含寻址；
	- 指令中设置寻址方式字段 —— 显式寻址。

![|500](https://i.imgur.com/QsCSmgA.png)
- 间接寻址可以理解为指针。
- PC相对寻址：用于条件转移指令。
![|700](https://i.imgur.com/0aWFMuz.png)
- 例题：
![|600](https://i.imgur.com/LYlNEvW.png)



### 5.4 操作码和编码

1. 指令长度设计
- 一般原则
	- 指令长度为存储器最小可寻址单位的整数倍：CISC（X86）
	- 指令长度一般设计为总线宽度的整数倍：RISC

1) 定长操作码（RISC）
- 指令系统共N条指令，所有指令均用n位编码，应满足：N≤2n
- 从2n个编码中选出N个编码，用来表示N条指令的操作码。
- 优点：操作码构造简单，硬件设计简单，译码速度快。
- 缺点：操作码占存储空间大；指令规模扩充受限。

2) 变长操作码

- 编码方式：对不同类型的指令操作码用不固定长度的二进制数进行编码。
- 设计原则：
	- 如果指令字长度固定，则长地址码对应短操作码，操作码长度随地址码长度缩短而增加。
	- 如果指令字长度可变，则以指令使用频度作为设计依据，使用频度高的指令用短码，使用频度低的指令用长码 —— 霍夫曼(Huffman)编码原理。
	- 设计总是从短操作码开始，并要保证当前使用的操作码与未来要扩展的操作码能够有效区分。
	- 原则：短码不能是长码的前缀。

3) 哈夫曼树构造步骤
1. 把所有指令按照操作码在程序中出现的概率大小，自左向右顺序排列。
2. 选取两个概率最小的结点合并成一个概率值是二者之和的新结点，并把这个新结点与其它还没有合并的结点一起形成一个新的结点集合。
3. 在新结点集合中选取两个概率最小的结点进行合并，如此继续进行下去，直至全部结点合并完毕。
4. 最后得到的根结点的概率值为1。
5. 每个新结点都有两个分支，分别用带有箭头的线表示，并分别用一位代码“0”和“1”标注。
6. 从根结点开始，沿尖头所指方向寻找到达属于该指令概率结点的最短路径，把沿线所经过的代码排列起来就得到了这条指令的操作码编码。

4) 霍夫曼编码
- Huffman编码不惟一：
	- 0、1对换
	- 合并次序
- 只要采用全Huffman编码，操作码的**平均码长肯定是唯一的**。

5) 扩展操作码（X86）

【例】假设某型号的计算机共有14条指令，各条指令的使用频率分别为：0.01、0.15、0.12、0.03、0.02、0.04、0.02、0.04、0.01、0.13、0.15、0.14、0.11、0.03。
试给出定长、只能有两种码长的扩展操作码，霍夫曼编码的三种编码方案，并计算各种方案的平均码长。

【解】
![|500](https://i.imgur.com/2VA9KTx.jpg)
![|500](https://i.imgur.com/KrKy0Wd.png)
![|500](https://i.imgur.com/80IcAA4.jpg)

【例5.4】某指令系统的指令长度确定为32位，由三地址、二地址、一地址、零地址指令组成，其中各类指令中地址字段位数如下表，则各类指令的操作码可以设计为几位？各类指令数最多可以是多少？
【解】三地址指令:	操作码6位，  指令数 n3 ≤ 26-1
双地址指令:	操作码11位，指令数 n2 ≤ (26-n3)·25-1
单地址指令:	操作码16位，指令数 n1 ≤ ((26-n3)·25-n2)·25-1
零地址指令:	操作码32位，指令数 n0 ≤ (((26-n3)·25-n2)·25-n1)×216

【例】若某机器要求有如下形式的指令：三地址指令4条，单地址指令255条，零地址指令16条。
设指令字长为12位，每个地址码长3位，那么能否以扩展操作码进行编码？
如果单地址指令为254条，其他不变，是否可以进行扩展操作码编码？
![|550](https://i.imgur.com/PmKzI4B.jpg)

某计算机指令字长16位，有单地址指令和双地址指令两类。若每个地址字段均为6位，且双地址指令有m条，那么单地址指令最多可以有多少？
![|550](https://i.imgur.com/tPpR2tT.png)
【解】单地址指令最多 (24－m)×26 条。

<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://i.imgur.com/3Ssbdzh.jpg" width="90%" />
			</center>
		</td>
		<td>
			<center>
				<img src="https://i.imgur.com/b7j6qrn.jpg" width="90%" />
			</center>
		</td>
	</tr>
</table>


【解】
1. 最多26＝64条指令；最多23＝8个通用寄存器；该计算机内存按字编址(一个内存地址存放两个字节)，内存地址空间为128KB÷2B=64K，MAR、MDR各需16位。
2. 转移指令的相对偏移量(补码)为 -215～215-1，即 -32768到+32767；转移指令的目标地址范围是0000H～FFFFH
3. 汇编语句：SUB  (R1), (R2)+
  (SUB为减法指令助记符；逗号前为源操作数，逗号后为目的操作数)
- a) 若减法指令操作码为001101，写出该汇编语句的机器码  
	- 001101 01 001 10 010 B，即3532H
- b) 该指令执行后，哪些寄存器和存储单元的内容会改变？改变后的内容为多少？
	- ![|300](https://i.imgur.com/GpYWjOh.png)
	- ![|300](https://i.imgur.com/cmn3VEC.png)
### 5.5 典型指令系统

1. Inter x86
2. MIPS
- 指令格式


## 第六章 中央处理器（CPU）

### 6.1 简化的单总线结构的CPU

![|500](assets/Pasted%20image%2020220821133222.png)

![|500](assets/Pasted%20image%2020220821154957.png)

相关概念：
- 指令周期，CPU周期，节拍周期。

2. 微操作
1) 流程
- 时序信号的产生

### 6.2 硬布线控制器设计
- 控制器的输出信号
![|600](assets/Pasted%20image%2020220822124935.png)
![|600](assets/Pasted%20image%2020220822125120.png)
![|600](assets/Pasted%20image%2020220822125151.png)


- 控制器的输入信号
	- 时序信号——两级时序
- 取指周期
![|600](assets/Pasted%20image%2020220822125912.png)
- 执行周期（各个指令分别介绍）
![|600](assets/Pasted%20image%2020220822130115.png)
![|600](assets/Pasted%20image%2020220822130240.png)
![|600](assets/Pasted%20image%2020220822142744.png)
![|600](assets/Pasted%20image%2020220822143036.png)
![|600](assets/Pasted%20image%2020220822143705.png)
![|600](assets/Pasted%20image%2020220822143949.png)
![|600](assets/Pasted%20image%2020220822144156.png)
![|600](assets/Pasted%20image%2020220822144244.png)
![|600](assets/Pasted%20image%2020220822144752.png)
![600](assets/Pasted%20image%2020220822144919.png)
![|600](assets/Pasted%20image%2020220822145052.png)
![|600](assets/Pasted%20image%2020220822153757.png)
![|600](assets/Pasted%20image%2020220822153838.png)
![|800](assets/Pasted%20image%2020220822154432.png)

- 一级时序（只产生节拍信号）

![|800](assets/Pasted%20image%2020220822154612.png)
![|800](assets/Pasted%20image%2020220822154654.png)

其特点如下：
- 每个控制信号的逻辑表达式就是一个与或逻辑方程式。
- 用一个与或逻辑电路就可以实现该控制信号的生成。
- 将所有控制信号的与或逻辑电路组合在一起就构成了硬布线控制单元。
- 时间信息、指令信息、状态信息是硬布线控制单元的输入，控制信号是硬布线控制单元的输出。
- 采用硬布线法设计控制器的特点：
	- 一旦完成了控制器的设计，改变控制器行为的唯一方法就是重新设计控制单元 → 修改不灵活
	- 在现代复杂的处理器中，需要定义庞大的控制信号逻辑方程组 → 与或组合电路实现困难
		- 微程序设计法


### 6.3 微程序控制器设计

![|500](assets/Pasted%20image%2020220823143730.png)
![|400](assets/Pasted%20image%2020220823144531.png)

- 微指令与微程序
- 两地址方式
- 可变格式
- 控制域编码
	- **字段译码法** （NOP，PC/SP的合并，Mread和IOread/Mout和IOout的合并）
- 微程序段
![](assets/Pasted%20image%2020220823163848.png)
![](assets/Pasted%20image%2020220823164250.png)

- 微程序控制器
	- 比硬布线控制器速度慢
	- 设计简单化、规范化
	- 功能可修改、可扩充
	- 实现成本低，出错概率小
	- 常用于CISC处理器控制器的实现（Intel x86）
- 硬布线控制器
	- 速度快
	- 当计算机系统复杂时，设计困难
	- 一旦实现，不可修改和扩充
	- 常用于RISC处理器控制器的实现

### 6.4 CPU性能的测量与提高，CPU中的新技术

- 衡量CPU的方法：
	- CPU 时间
	- **CPI**：（Clock cycles per Instruction）：每条指令执行所用的时钟数。
	- MIPS
	- FLOPS

- 多核技术

【实例】三台不同配置的计算机：
A. 标准单核处理器超频20%；
B. 标准单核处理器；
C. 双核处理器，每一个核降频20%。
上述三台不同配置的计算机运行同一套应用程序，对其功耗及性能进行比较：
![500](assets/Pasted%20image%2020220823181543.png)
结论：
- 与直接提升处理器频率相比，对于适当类型的应用程序，多核处理器提供了更高的性能，而其功耗仅有少量增加。
- 并不是所有应用程序都能平等地利用多核处理器。要实现这些性能上的提升，需要开发者做出大量的工作。

多线程技术


## 第七章  流水线技术与指令集并行

### 7.0 概述

- 通常提高指令执行速度的途径有如下三种：
	- 提高处理机的工作主频。
	- 采用更好的算法和设计更好的功能部件。
	- 多条指令并行执行，称为指令级并行技术。    

- 可以从两个方面来开发处理机内部的并行性：
	- 空间并行性：即在一个处理机内设置多个独立的操作部件，并让这些操作部件并行工作，这种处理机称为 多操作部件处理机或超标量处理机；
	- 时间并行性：就是采用流水线技术。流水线技术是一种非常经济、对提高处理机的运算速度非常有效的技术。采用流水线技术可以不增加硬件或只需要增加少量硬件就能够把处理机的运算速度提高几倍，它是目前使用非常普遍的一种并行处理方式。

- 并行性的两种含义：
	- 同时性：同一时刻
	- 并发性：同一时间间隔
- 并行处理技术的三种形式：
	- 时间并行：时间重叠，流水
	- 空间并行：资源重复
	- 时间并行＋空间并行：超标量流水

### 7.1 流水线处理

- 若将一重复的处理过程分解为若干子过程，每个子过程都可在专用设备构成的流水线功能段上实现，并可与其它子过程同时执行，这种技术称为流水技术。 
- 若加载的信息是数据就可以构成数据处理或运算流水线（arithmetic pipeline）。
- 若加载的信息是指令就可以构成指令流水线（instruction pipeline）。

- 相关概念：
	- 流水过程由多个相联系的子过程组成，每个子过程由专用的功能设备实现，每个子过程称为流水线的“级”或“段”。“级”数称为流水线的“深度”；
	- 流水线需要有“通过时间”，在此之后流水过程才进入稳定工作状态，每一个时钟周期（拍）流出一个结果；
	- 流水线不能缩短单个任务的响应时间，但可以提高吞吐率；
	- 流水线速度受限于最慢流水线段的运行速度，所以，各个功能段所需时间应尽量相等；
	- 流水技术适合于大量重复的处理过程，只有流水线的输入能连续地提供任务，流水线的效率才能充分发挥。
	- 流水线中多个任务是并行处理的。

- 分类
	- 按流水线位于计算机系统的层次划分：
		- 系统级流水线/宏流水线：在多（计算）机系统中由多个处理机串行构成的流水线。
		- 处理器级流水线（由部件构成）
		- 部件级流水线（在部件内部）
	- 按流水线功能的强弱划分：
		- 单功能流水线
		- 多功能流水线
			- 静态流水线
			- 动态流水线
	- 按流水线是否有反馈回路划分：
		- 线性流水线（能够用流水线连接图唯一表示）
		- 非线性流水线－流水线调度（必须用流水线连接图和流水线预约表共同表示）
	- 按流水线输出端任务流出顺序与输入端任务流入顺序是否相同划分：
		- 顺序流动流水线（入出顺序相同）
		- 异步流动流水线（入出顺序不同）无序流水线 / 错序流水线 / 乱序流水线
	- 按流水线一次处理对象的数量划分：
		- 标量流水线：IBM System360/91、Amdahl 470V/6
		- 超标量流水线：MIPS R10000
		- 向量流水线：TI ASC、STAR-100、CYBER-205、CRAY-1、YH-1
		- 超长指令字流水线：Intel Itanium（EPIC IA-64）


### 7.2  浮点运算流水线

- 浮点数加减法/乘除法流水线设计

- 一种流水线结构的定点乘法器的实现：若两个n位定点二进制数为X=xn-1xn-2…x0和Y=yn-1yn-2…y0，则2n位乘积P为：
![|600](assets/Pasted%20image%2020220903151029.png)
![|200](assets/Pasted%20image%2020220903151035.png)
→ 乘法的实现是通过一组Mi的求和来实现的
→ 进位保留加法(Carry-Save addition)
- 流水线 进位保留乘法器（Wallace树）->与阵列乘法器的对比
- ![|500](assets/Pasted%20image%2020220903151231.png)

### 7.3 指令流水线
   
1. 增加指令流水线深度
- 采用深度指令流水线结构：将指令的执行过程进一步细化，使流水线的级（段）数变多，而每一级的工作更少、更合理。
- 这样做有两个好处：
	- 流水线级数变多、处理更趋合理，可使单条指令流水线并行执行指令的能力更强；
	- 每一级的处理时间更短，可以进一步提高处理器的工作频率。
- 深度指令流水线可以使处理器执行指令的速度更快、效率更高。
- 增加流水线的深度可以提高流水线的性能，但：
	- 流水线深度受限于流水线的延迟和额外开销；
	- 需要用高速锁存器作为流水线的缓冲寄存器。
- 由J.G.Earle在1965年发明的Earle锁存器是一种具有良好性能的高速锁存器，具有如下优点：
	- 对时钟扭曲（clock skew）相对而言不敏感，一般是两级门的延迟时间，避免了数据通过锁存器时可能产生的时钟扭曲；
	- 在锁存器中可以实现两级逻辑运算，而不会增加锁存器的延迟时间，这样，每个流水线中的两级逻辑可以与锁存器重叠，从而隐藏锁存器产生的额外开销。
- 增加指令流水线的深度的局限：
	- 指令执行过程的细化是有限度的
	- 随着流水线深度的增加，流水线段之间的缓冲器增多，延迟加大，使流水线的性能提高受到阻碍


2. 增加指令流水线条数
- 多指令流水线结构（超标量流水线）
	- Intel Pentium 处理器：
		- U指令流水线（主流水线）
		- V指令流水线（副流水线）
	- IBM PowerPC 601
	- 多核CPU


### 7.4  流水线性能度量

1. 时-空图
- 通过时间＝(流水线级数－1)×时钟周期
- 细分瓶颈段/重复设置瓶颈段 

2. 吞吐率
- 吞吐率：单位时间内流水线所完成的任务数或输出结果的数量。（任务数除以所花的时间）
- 最大吞吐率TPmax：流水线在达到稳定状态后所得到的吞吐率。
	- 假设流水线各段运行时间相等，为1个时钟周期TCLK ，则：TPmax = 1/TCLK
	- 假设流水线各段运行时间不等，第i 段时间为τi ，则：TPmax = 1/max{τi } = 1 /τ
- 最大吞吐率取决于流水线中最慢一段所需的时间，所以该段成为流水线的瓶颈。消除瓶颈的方法有：
	- 细分瓶颈段
	- 重复设置瓶颈段

- 注意：指令流水线的时钟周期就是CPU的时钟周期，倒数即为CPU的主频。

- 实际吞吐率：若流水线由m段组成，完成n个任务的吞吐率称为实际吞吐率，记作TP。
- 使TP最大化，或使TP接近于TPmax，是流水线实现中重点要解决的问题。
- 假设流水线各段运行时间相等，为1个时钟周期TCLK，在不出现流水线断流的情况下，完成n个任务所用时间为：Tn(m) = (m＋(n－1))×τ = (m＋(n－1))×TCLK  实际吞吐率为：（m 段流水线，n 个任务。）
![|500](assets/Pasted%20image%2020220903160302.png)
- 假设流水线各段运行时间不等，第i段时间为τi ，则完成n个任务所用时间为
![|500](assets/Pasted%20image%2020220903160322.png)
- 实际吞吐率为：
![|300](assets/Pasted%20image%2020220903160337.png)

- 当n很大时，TP趋近于TPmax，这说明流水技术适合于实现大量重复的时序过程。

- 对于指令流水线而言，吞吐率TP就是每秒执行的指令数，所以也可以用MIPS指标表示吞吐率，即：TP＝MIPS＝fCLK /CPI
- 单流水线计算机系统∵ CPI最佳 ＝1，  ∴ TPmax＝fCLK 

3. 加速比

- 若流水线为m段，加速比S定义为等功能的非流水线执行时间T(1) 与流水线执行时间T(m)之比，即S=Sn(m) = Tn(1)/Tn(m)
- 若每段运行时间均为τ，在不流水情况下，完成n个任务所需时间为：Tn(1)= n · mτ
- 在流水但不出现断流的情况下，完成n个任务所需时间为：Tn(m)= mτ + (n-1)τ ，因此（m 个功能段，n 个任务）
![|400](assets/Pasted%20image%2020220903160839.png)
- 增大指令流水线的级数和送入流水线的指令数均可以加速流水线的运行速度

4. 效率
- 效率：流水线的设备利用率
- 由于流水线有通过（填充）时间和排空时间，所以流水线的各段并非一直满负荷工作，效率E＜1。
- 假设流水线各段运行时间相等为τ，各段效率ei 也相等，即e1 = e2 =… = em = nτ/Tn(m)（m段流水线完成n个任务所需的时间）
- 则整个流水线效率E为（m 个功能段，n 个任务。）：
![|500](assets/Pasted%20image%2020220903161729.png)
当n>>m时，E≈1。

- 从时-空图上看，效率就是n个任务所占的时空区与m个段总的时空区之比。根据这个定义，可以计算流水线各段时间不等时的流水线效率为：
![|400](assets/Pasted%20image%2020220903161850.png)

5. 吞吐率、加速比和效率的关系
- 效率是实际加速比S与最大加速比m之比。
	- E ＝ nτ/ Tn(m) ＝ mnτ/ (Tn(m)·m) ＝  S/m
- 当τ不变时，流水线的效率E与吞吐率TP呈正比。
	- E ＝ nτ/ Tn(m)＝ (n/Tn(m)) ·τ＝ TP ·τ
- 当m和τ不变时，流水线的加速比S与吞吐率TP呈正比。
	- TP＝ S/(mτ)

6. 流水线性能分析与相关例题
【例7.1】某处理器中，浮点加法器采用4级流水线实现，流水线示意图见图7.7和图7.19(a)所示，每级处理时间为250ps。请确定：
（1）该浮点加法器计算100组数据采用非流水和流水处理所用时间各是多少？
（2）采用流水处理的加速比是多少？
（3）采用流水处理的最大吞吐率是多少？
![|400](assets/Pasted%20image%2020220903162021.png)![|400](assets/Pasted%20image%2020220903162030.png)
- 采用非流水处理所用时间为
	- Tn(1)= nmτ = 100×4×250ps = 100ns
- 采用流水处理的时-空图见图7.19(b)所示，所用时间为
	- Tn(m)= mτ + (n-1) τ = (4+100-1)×250ps = 25.75ns
- 加速比为（理想加速比为4）
 ![|400](assets/Pasted%20image%2020220903162233.png)
- 最大吞吐率为
	- TPmax = 1/τ = 1/250ps = 4 GFLOPS

例题：详见视频P32。

- 流水线气泡时间
- 同步时钟控制与**异步时钟控制**
- 流水线采用异步控制并没有给流水线性能带来改善，反而会增加控制电路的复杂性。所以，流水线采用的基本控制方式为同步方式。
- 各段处理时间不等：**异步时钟控制，且找瓶颈段即可**。


### 7.5 指令流水线的性能提高

- 限制指令流水线性能提高的因素：
	- 流水线的深度受限于流水线的延迟、流水线段的时间不均衡和流水线的额外开销。
	- 指令执行时可能存在的相关（dependence）或“冒险(hazard)”问题。
- 相关：相邻或相近的两条指令因存在某种关联，后一条指令不能在原指定的时钟周期开始执行。
- 相关或冒险有3类：
	- 局部性相关
		- 结构（structural）相关：资源冲突
		- 数据（data）相关：一条指令需要用到前面某条指令的结果
	- 全局性相关
		- 控制（control）相关：分支等转移类指令/其他能够改变PC值的指令

1. 结构相关
- 有两种情形会导致结构相关：
- 部分功能单元没有充分流水。
	- 解决办法：将流水线设计的更合理。
- 资源冲突（resource conflicts）：当两个以上流水线段需要同时使用同一个硬件资源时，发生冲突。解决方法：
	- 增加资源副本：
		- 存储器冲突：哈佛结构
		- 两个ALU：取指令－地址加法器
	- 改变资源以便它们能并发的使用。
		- 不相关的数据尽量使用不同的寄存器
		- 寄存器重命名
	- 通过延迟（或暂停）流水线的冲突段或在冲突段插入流水线气泡（气泡在流水线中只占资源不做实际操作），使各段“轮流”使用资源。

2. 数据相关
- 相关类型：
	- **先写后读**（Read After Write）（RAW）
	- 先读后写（Write After Read）（WAR）
	- 写－写（Write After Write）（WAW）

- 解决办法：
- 采用直通（forwarding）技术（相关直接通路）。
	- 将运算结果经相关直接通路直接送入所需部件。
- 增加专用硬件（推后法）
	- 增加流水线互锁（pipeline interlock）硬件。互锁硬件先要检测流水线中指令的数据相关性，当互锁硬件发现数据相关时，使流水线工作停顿下来，直到相关消失为止。
- 利用编译器
	- 流水线调度/指令调度：编译器可以对指令重新排序或插入空操作指令，使得加载任何冲突数据的操作被延迟，但对程序逻辑或输出不受影响。

- 数据重定向技术
- Tomasulo算法


3. 控制相关
- 使程序执行顺序发生改变的转移指令有两类：
	- 无条件转移指令（如无条件跳转、调用、返回指令等）
		- 某些CPU（如UltraSPARC III）：紧跟在无条件转移指令之后的指令必须执行。
		- 另一些CPU：采取相对复杂的方法，如提前计算出转移目标地址。
	- 条件分支转移指令（为零跳转、循环控制指令等）
		- 不仅需要延迟槽，而且一直到流水线的深处，取指单元才能知道到哪里去取下一条指令。
		- 条件分支指令对流水线性能的影响远比无条件转移指令要大。
- 分支延迟槽（branch delay slot）：程序中位于转移指令后面的存储单元位置。
- 对条件分支指令的处理方法
	- 冻结流水线
	- 预取分支目标
	- 多流
	- 循环缓冲器
	- **分支预测**
		- 静态分支预测
			- 预测分支不会发生
			- 预测分支总是发生
			- 由编译器预测
			- 测试法
		- 动态分支预测
			- 分支历史表
			- 分支历史移位寄存器
	- 延迟分支（RISC）
	- 加快和提前生成条件码

### 7.6  指令级并行

- Tomasulo算法

![|600](assets/Pasted%20image%2020220906191607.png)
- 解决访存冲突的方法——先行控制技术
- 采用先行控制技术的关键是缓冲技术和预处理技术。

流水机器的中断处理
- 主要任务：如何处理好断点现场的保护和恢复，而不是缩短流水线的断流时间。
- 方法：
	- “不精确断点”法。如：IBM 360/91
		- 缺点：不利于程序的设计和排错。
	- “精确断点法”法。如：Amdahl  470/V6需设置很多后援寄存器，以保证流水线内各条指令的原有现场都能保存和恢复。

### 7.8 多发射处理器

1. 超标量：Superscalar
- 为了充分利用**度（几条流水线同时工作）**为m的超标量处理器，m条指令必须是可并行执行的，否则流水线停顿。
- 超标量处理器芯片含有多个独立的执行单元，每个单元采用流水结构。
- 采用乱序发射、重命名技术。
- 每指令时钟数CPI实际低于1，通常 IPC＝2～6 。

2. 超长指令字处理器

- VLIW的主要特点
	- 采用显式并行指令计算（EPIC：Explicitly Parallel Instruction Computing）方式。
		- 在VLIW处理机上运行的程序是一个二维指令矩阵，每一行上的所有操作组成一条超长指令，他们之间没有数据相关、控制相关和功能部件冲突，这些指令可以在VLIW处理机上同时执行。
		- 超标量处理机和超流水线处理机通常采用隐式并行指令方式。程序是一维线性的指令序列，每条指令中一般只包含一个操作。
	- 指令级并行度高。
		- 超标量处理机和超流水线处理机的指令级并行度一般为2左右，通常不超过4；目前多数VLIW处理机的指令级并行度在4至8之间，有的已经达到几十。
		- 在VLIW中通过并行编译器来开发程序中的指令级并行性，可以在一个循环、一个函数、甚至整个程序中寻找指令级并行性；而且，可以采用软件流水、循环展开等指令级并行度很高的方法充分开发程序中的多种并行性。
	- 硬件结构规整、简单。
		- VLIW处理机主要由很规则的寄存器、存储器、运算部件和数据通路等组成，不规则的控制器很简单，而且，不需要复杂的指令并行调度窗口及多发射机制等。
	- 编译器的实现难度大。
		- VLIW并行编译器主要依靠指令级并行算法、数据相关性分析算法、寄存器分配算法及并行编译技术等来显式开发程序中的指令级并行性，从而提高处理机的运行速度。要研制指令级并行度高的编译器难度很大。

### 补充1 分支预测与推测执行
- 测信道攻击
- Meltdown和Spectre漏洞

### 补充2 15分钟读懂幽灵熔断漏洞


## 第八章 总线与输入输出系统

### 8.1  总线与输入输出系统概述

- 组成计算机的三类模块：CPU、存储器、I/O设备
- 互连结构(互连网络)：连接这三类模块通路的集合。
	- 专用通路：仅在两个部件之间传递信息的通路。
	- 共享(公用)总线：在不同时刻(分时)传递不同部件之间信息的通路。
- 总线：计算机系统中多个部件或设备共用的传递信息的电子通道。

- 输入输出系统的组成：
	- 输入输出设备
	- 输入输出接口
	- 输入输出控制器
	- 输入输出控制管理软件
- 输入输出系统的功能：
	- 将各种输入输出设备有效地接入到计算机系统中；
	- 将计算机外部的输入设备的信息输入到计算机内部，以便能够得到加工处理，该功能简称为输入操作；
	- 将计算机内部存储或加工处理的信息输出到计算机之外，以提供给计算机外部的输出设备使用，该功能简称为输出操作。
	- 数据在外存中进行存、取的操作。

- 外设的分类：
	- 字符设备（Character device）
	- 块设备（Block device）
- 基本输入输出技术：
	- 程序查询方式
	- 中断控制方式
	- DMA(直接存储器存取)方式
	- 通道控制方式

### 8.2 总线
- 总线：
	- 是计算机系统的**互连机构**
	- 是连接两个或多个总线设备的公共通信线路
	- 是一组有定义的、可共享的、可传递0、1逻辑信号的连接线
	- 通常分为地址总线、数据总线、控制总线
- 总线设备：
	- 主设备（Master）->发出信号（地址，控制信号）
	- 从属设备（Slave）->接受命令

1. 分类
- 按连接层次分类：
	- 片内总线
	- 系统总线
	- 通信总线  （后两者往往为标准化总线）
- 按数据位数分类：
	- 并行总线
	- 串行总线
- 按用法分类：
	- 专用总线：只连接一对功能部件
	- 公用(共享)总线

2. 总线结构
3. 总线的信息传输方式

- 总线上进行一次传输的过程：
	- 传输请求
	- 总线仲裁
	- 部件/设备寻址
	- 数据传输
	- 总线释放
- 数据传输的基本方式：
	- 并行传送方式
	- 串行传送方式
	- 分时传送方式
	- 消息传送方式


4. 总线的通信方式
- 同步通信方式
	- 优点：速度快，接口逻辑简单。
	- 缺点：
		- 总线上的每个设备必须以**相同的时钟频率**运行，且时钟速率依**慢速设备**而定；
		- 时钟偏移（clock skew）问题：总线时钟频率↑ =>  总线长度↓
- 异步通信方式
	- 无时钟信号线
	- 使用握手协议（handshaking protocol）
		- 非互锁、半互锁、全互锁
		- 串行异步通信：不用握手信号、无时钟信号
 
- 由发送设备发起的异步数据传输握手时序：非互锁、半互锁、全互锁 方式
- 由接收设备发起的异步数据传输握手时序

5. 总线仲裁

- 主方：启动一个总线周期
- 从方：响应主方的请求
- 多处理器系统，各CPU模块的总线请求：**公平**
- I/O模块的总线请求：**优先级**
- 总线仲裁(Bus Arbitration)： 用来决定哪个主设备可以使用总线的选择机制。
- 按照总线仲裁电路位置不同，仲裁方式可分为：
	- 集中式仲裁
		- 链式查询方式（菊花链）
		- 计数器定时查询方式（轮询）
		- 独立请求方式
	- 分布式仲裁
		- 如：SCSI总线

1. 集中式仲裁：链式查询(菊花链) （可以理解为集电极开路的情况，实现线与逻辑）
- 特点：使用总线的优先次序完全由“总线可用”线所接部件的物理位置来决定，离总线控制器越近的部件其优先级越高。
- 优点：
	- 优先级选择算法简单。
	- 用于分配总线所需的线数少，只需要3根，且不取决于部件的数量→可扩充性好。
	- 价格便宜。
	- 易于通过多重设置“总线可用”线来提高其系统的可靠性。
- 缺点：
	- 可靠性差： “总线可用”线失效，会导致系统瘫痪。
	- 灵活性差：优先级顺序固定。
	- 总线使用的分配速度低。


















# 课程评价
