---
tags: 自学 计算机 计算机系统基础
---

# 前言

本门课程为ICS习题课，是南京大学的计算机系统基础习题课。**内含PA实验，最好能够完成。**
同时，此课程也是中科院：[一生一芯学习路线](../../芯片/一生一芯/一生一芯学习路线.md)计划的重要课程。
目前的学习方法：先看2020版，用2021版2倍速观看作为补充。

课程链接：[[完结] 2020 南京大学计算机系统基础习题课 (蒋炎岩)](https://www.bilibili.com/video/BV1qa4y1j7xk?spm_id_from=333.999.0.0&vd_source=f6d522f28072721da0e962ed83629041)（2020年课程）
[计算机系统基础习题课ICS_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Z541127RJ?p=1)（2021年课程）
[计算机系统基础习题课 (2020 秋季学期) (jyywiki.cn)](http://jyywiki.cn/ICS/2020/)
[南京大学 计算机科学与技术系 计算机系统基础 课程实验 2022](https://nju-projectn.github.io/ics-pa-gitbook/ics2022/)


# 课程笔记

## 0. 课程导读与实验要求


## 1. C语言拾遗（1） 机制

概述：**编译，链接，加载，执行的过程**；RTFSC时需要关注的C语言特性。

.c->预编译（-E)->**.i->编译(-S)->.s（人类可读的文本文件）**->汇编(-c)->.o（计算机可读的文件）->链接->.out       加载执行：./a.out      (注意，**此处s和S不同**)
可以用gcc去编译他：**gcc a.c**  (会执行上述步骤，最终生成a.out)
- linux中，x代表可执行权限。windows则用.exe表示。 
- 利用vim打开.out后，用:%!xxd指令，可以将该文件转化为二进制/十六进制文件。
- 了解gcc的方法：（1）gcc -help  （2）tldr gcc    （too long to read)
- objdump -d                              用来查看一个汇编文件/二进制文件的反汇编。

### 1.1 预编译

- \#include ：指**文件原样复制粘贴过来**。
- \#\#：双井号代表连接
- \#include <stdio.h> 和\#include "stdio.h" 的区别
	- 探寻方法：verbose mode(详细模式)     gcc a.c --verbose 
	- 前者：去系统找
	- 后者：去当前目录找 （可以利用-I 将当前目录添加入系统，即也可以用\#include<>） 例如：gcc a.c -I.
- 请问下面代码的结果是？
	- 答案是Yes。 （本质原因：**aa/bb都没定义，故实际上是空=空**）
	- 本质上，C语言所有**带\#的均在预编译做复制粘贴处理**。
```c
#include<stdio.h>
int main(){
#if aa==bb
	printf("Yes\n");
#else
	printf("No\n");
#endif
}
```

总结：
- 宏定义与展开
	- 宏展开：通过复制/粘贴改变代码的形态。
- 预编译也称为元编程。其优缺点如下：
	- 优点：提供更灵活的写法（X-macros）及接近自然语言的写法
	- 缺点：破坏可读性IOCCC、程序分析（补全）

### 2. 编译与链接（总览）

- 编译器：将高级语言代码翻译成汇编代码的工具。
	- **C语言的连续一段代码总能找到一段连续的机器指令**。
- 链接：将多个二进制目标代码拼接在一起。 例如：gcc a.o b.o -static

### 3. 加载

C程序执行的两个视角
- 静态：C代码的连续一段总能对应到一段连续的机器指令
- 动态：C代码执行的状态总能对应到机器的状态
	- 源代码视角：函数，变量，指针
	- 机器指令视角：寄存器，内存，地址
- 两个视角的共同之处：**内存**
	- 代码/变量（源代码视角）=地址+长度（机器指令视角）
	- （不太严谨的）内存=代码+数据+堆栈
- **因此理解内存模型非常重要**

C语言中一切皆可取地址，包括代码，数据，堆栈。在汇编语言的视野里，所有东西都是地址。**整个程序所做的事就是一个状态机**，所作的唯一的事就是指令从内存中读取内容，存到寄存器，算一下再写到内存
- void 类型的指针（如 void \*P) 代表与一个纯粹的指针
- 其他类型的指针（如 int \*p) 代表他首先是一个纯粹的指针，前缀是他指向内存的解读。

C Type System
- 类型：对一段内存的解读方式
	- 非常 “汇编”——没有 class, polymorphism, type traits, ...
	- C 里所有的数据都可以理解成是地址 (指针) + 类型 (对地址的解读)
```C
#include<stdio.h>
#include<assert.h>
int main(int argc, char *argv[]) {   //argc 四个字节，argv 八个字节
int (*f)(int, char *[]) = main; 
if (argc != 0) { 
	char ***a = &argv, *first = argv[0], ch = argv[0][0]; 
	printf("arg = \"%s\"; ch = '%c'\n", first, ch); 
	assert(***a == ch);  //if（xxx)成立，什么都不做，else，返回error message。
	f(argc - 1, argv + 1); 
	} 
}
```

-   C 语言简单 (在可控时间成本里可以精通)
-   C 语言通用 (大量系统是用 C 语言编写的)
-   C 语言实现对底层机器的精确控制 ([鸿蒙](https://openharmony.gitee.com/openharmony))
-   推荐阅读：[The Art of Readable Code](https://www.oreilly.com/library/view/the-art-of/9781449318482/)



##  2.C语言拾遗（2） 编程实践

概述：怎么样写代码才能从一个大型项目里存活下来？ 
作业：**HW1，Lab1**
- 核心准则：**编写可读代码**
- 两个例子

1. 一个极端的例子：不可读（不可维护）的代码
- gcc -E hou.c | indent -  （| pygemntize）      格式化代码（高亮）

2. 一个可能遇到的例子：人类不可读版（STFW:clockwise/spiral rule）
- 人类不可读：void (\*signal(int sig, void (\*func)(int)))(int);
- 人类可读（本部分代码可见linux手册中signal部分）：
	- typedef void (\*sighandler_t)(int);   //typedef 给某一东西起别名。
	- sighandler_t signal(int, sighandler_t);

3. 编写代码的准则：降低维护成本

Programs are meant to be read by humans and only incidentally for computers to execute. — _D. E. Knuth_
(程序首先是拿给人读的，其次才是被机器执行。)

- 宏观
	- 做好**分解和解耦** (现实世界也是这样管理复杂系统的)
	- 有同学问：PA 是否允许添加额外的文件？
- 微观
	- “不言自明”
		- 通过阅读代码能理解一段程序是做什么的 (specification)
	- “不言自证”
		- 通过阅读代码能验证一段程序与 specification 的一致性

### 2.1 实现数字逻辑电路的模拟器

**假想的数字逻辑电路，你会如何设计**？
- 若干个 1-bit 边沿触发寄存器 (X, Y, ...)
- 若干个逻辑门

- 基本思路：状态 (存储) 模拟 + 计算模拟
	- 状态 = 变量
		- int X = 0, Y = 0;
	- 计算
		- X1 = !X && Y;
		- Y1 = !X && !Y;
		- X = X1; Y = Y1;

若要增加一个触发器，加一个Z，则需要进行多处改动。故可用如下代码进行改进（预编译）
```C
#define FORALL_REGS(_)  _(X) _(Y)
#define LOGIC           X1 = !X && Y; \
                        Y1 = !X && !Y;
#define DEFINE(X)       static int X, X##1;
#define UPDATE(X)       X = X##1;
#define PRINT(X)        printf(#X " = %d; ", X);

int main() {
  FORALL_REGS(DEFINE);
  while (1) { // clock
    FORALL_REGS(PRINT); putchar('\n'); sleep(1);
    LOGIC;
    FORALL_REGS(UPDATE);
  }
}
```

该代码的优缺点
- Good
	- 增加/删除寄存器**只要改一个地方**
	- 阻止了一些编程错误
		- 忘记更新寄存器
		- 忘记打印寄存器
	- “不言自明” 还算不错
- Bad
	- **可读性变差 (更不像 C 代码了)**
		- “不言自证” 还缺一些
	- 给 IDE 解析带来一些困难
更完整的实现：数码管显示

### 2.2 实现YEMU全系统模拟器

从课本的计算机系统开始，实现简易的NEMU（**不需要从门层面实现它**）

1. YEMU的设计与实现
- 存储模型：内存 + 寄存器 (包含 PC)
	- 16 + 5 = 21 bytes = 168 bits
	- 总共有$2^{168}$种不同的取值
		- 任给一个状态，我们都能计算出 PC 处的指令，从而计算出下一个状态

- 理论上，**任何计算机系统都是这样的状态机**
	- (M,R)构成了计算机系统的状态
	- 32 GiB 内存有$2^{274877906944}$种不同的状态……
	- 每个时钟周期，取出M\[R\[PC]]的指令；执行；写回
		- 受制于物理实现 (和功耗) 的限制，通常每个时钟周期只能改变少量寄存器和内存的状态
		- (量子计算机颠覆了这个模型：同一时刻可以处于多个状态)

2. 模拟存储
**存储是计算机能实现 “计算” 的重要基础**。
- 寄存器 (PC)、内存
- 这简单，用全局变量就好了！
```C
#include <stdint.h>
#define NREG 4
#define NMEM 16
typedef uint8_t u8; // 没用过 uint8_t？
u8 pc = 0, R[NREG], M[NMEM] = { ... };
```
- 建议 STFW (C 标准库) → bool 有没有？
- 现代计算机系统：uint8_t == unsigned char
	- C Tips: **使用 unsigned int 避免潜在的 UB**
		- -fwrapv 可以强制有符号整数溢出为 wraparound
	- C Quiz: 把指针转换成整数，应该用什么类型？

3. 提升代码质量
```C
enum { RA, R1, ..., PC };
u8 R[] = {
  [RA] = 0,  // 这是什么语法？？   初始化
  [R1] = 0,
  ...
  [PC]  = init_pc,
};

/*当然 上述也可以写成u8 r[] = {    // 不如上述代码可读性好
	0,0,0,0,0, ... ,init_pc;
 }    */

#define pc (R[PC]) // 把 PC 也作为寄存器的一部分
#define NREG (sizeof(R) / sizeof(u8))   // 算出寄存器的数量，可维护性更强。
```

4. 从一小段代码看软件设计
软件里有很多隐藏的 dependencies (一些额外的、代码中没有体现和约束的 “规则”)
- 一处改了，另一处忘了 (例如加了一个寄存器忘记更新 NREG...)
- **减少 dependencies → 降低代码耦合程度**
```C
// breaks when adding a register
#define NREG 5 // 隐藏假设max{RA, RB, ... PC} == (NREG - 1)

// breaks when changing register size
#define NREG (sizeof(R) / sizeof(u8)) // 隐藏假设寄存器是8-bit

// never breaks
#define NREG (sizeof(R) / sizeof(R[0])) // 但需要R的定义  在大型项目中由于.c和.h分离，并不常用。

// even better (why?)
enum { RA, ... , PC, NREG }
```

PA 框架代码中的 CPU_state
```C
struct CPU_state {
};
// C is not C++
// cannot declare "CPU_state state";
#define reg_l(index) (cpu.gpr[check_reg_index(index)]._32)
#define reg_w(index) (cpu.gpr[check_reg_index(index)]._16)
#define reg_b(index) (cpu.gpr[check_reg_index(index) & 0x3]._8[index >> 2])
```
**对于复杂的情况，struct/union 是更好的设计。**
- 担心性能 (check_reg_index)？
	- **在超强的编译器优化面前，不存在的**


5. YEMU: 模拟指令执行（换句话说，就是**数字电路中模拟状态的转移**）
在时钟信号驱动下，根据 (M,R)更新系统的状态
- RISC 处理器 (以及实际的 CISC 处理器实现)：
	- 取指令 (fetch): 读出 M[R[PC]] 的一条指令
	- 译码 (decode): 根据指令集规范解析指令的语义 (顺便取出操作数)
	- 执行 (execute): 执行指令、运算后写回寄存器或内存
- **最重要的就是实现 idex()**
	- 这就是 PA 里最挣扎的地方 (囊括了整个手册)
	- 下面将介绍三种实现的方式
```C
int main() {
  while (!is_halt(M[pc])) {
    idex();
  }
}

// 代码例子1（可读性极差）
void idex() {
  if ((M[pc] >> 4) == 0) {
    R[(M[pc] >> 2) & 3] = R[M[pc] & 3];    //R[RT]=R[RS]
    pc++;
  } else if ((M[pc] >> 4) == 1) {
    R[(M[pc] >> 2) & 3] += R[M[pc] & 3];
    pc++;
  } else if ((M[pc] >> 4) == 14) {
    R[0] = M[M[pc] & 0xf]; 
    pc++;
  } else if ((M[pc] >> 4) == 15) {
    M[M[pc] & 0xf] = R[0];
    pc++;
  }
}

//代码例子2：不言自明？不言自证？
void idex() {
  u8 inst = M[pc++];
  u8 op = inst >> 4;
  if (op == 0x0 || op == 0x1) {
    int rt = (inst >> 2) & 3, rs = (inst & 3);
    if      (op == 0x0) R[rt]  = R[rs];
    else if (op == 0x1) R[rt] += R[rs];
  }
  if (op == 0xe || op == 0xf) {
    int addr = inst & 0xf;
    if      (op == 0xe) R[0]    = M[addr];
    else if (op == 0xf) M[addr] = R[0];
  }
}

//代码例子3（YEMU代码）
typedef union inst {
  struct { u8 rs  : 2, rt: 2, op: 4; } rtype;
  struct { u8 addr: 4,        op: 4; } mtype;
} inst_t;
#define RTYPE(i) u8 rt = (i)->rtype.rt, rs = (i)->rtype.rs;
#define MTYPE(i) u8 addr = (i)->mtype.addr;

void idex() {
  inst_t *cur = (inst_t *)&M[pc];
  switch (cur->rtype.op) {
  case 0b0000: { RTYPE(cur); R[rt]   = R[rs];   pc++; break; }
  case 0b0001: { RTYPE(cur); R[rt]  += R[rs];   pc++; break; }
  case 0b1110: { MTYPE(cur); R[RA]   = M[addr]; pc++; break; }
  case 0b1111: { MTYPE(cur); M[addr] = R[RA];   pc++; break; }
  default: panic("invalid instruction at PC = %x", pc);
  }
}
```

6. 小结：如何管理 “更大” 的项目 (YEMU)?
- 我们分多个文件管理它
	- yemu.h - 寄存器名；必要的声明（头文件全放在一个文件夹内）
	- yemu.c - 数据定义、主函数 
	- idex.c - 译码执行
	- **Makefile** - 编译脚本 (能实现增量编译)
		- 简易编译流程的介绍
		- CFLAGS->调用者的编译参数
		- 若所有依赖的子文件最后一次更新时间没有最终make的结果新，将不再执行make操作，弹出up to date。（换句话说，make工具会检查所有文件的时间戳，只编译那些修改过的文件）
			- 例如 可用touch 指令改变时间戳，观察现象

- 使用合理的编程模式
	- 减少模块之间的依赖
		- enum { RA, ... , NREG }
	- 合理使用语言特性，编写可读、可证明的代码
		- 有用的特性包括指针，Union/bit fields
			- 对于指针：内存只是个字节序列；无论何种类型的指针都只是地址 + 对指向内存的解读
		- inst_t \*cur = (inst_t \*\)\&M\[pc\]
- NEMU 就是加强版的 YEMU

7. 还有更多的系统级模拟器
- am-kernels/litenes
	- 一个 “最小” 的 NES 模拟器
	- 自带硬编码的 ROM 文件
- fceux-am
	- 一个非常完整的高性能 NES 模拟器
	- 包含对卡带定制芯片的模拟 (src/boards)
- QEMU
	- 工业级的全系统模拟器
		- 2011 年发布 1.0 版本
		- 有兴趣的同学可以 RTFSC
	- 作者：传奇黑客 Fabrice Bellard
